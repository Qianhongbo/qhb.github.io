<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linked list]]></title>
    <url>%2FLeetCode%2FLinked-list.html</url>
    <content type="text"><![CDATA[Merge Tow Sorted ListsQuestionExample 1: 12Input: list1 = [1,2,4], list2 = [1,3,4]Output: [1,1,2,3,4,4] Solution12345678910111213141516171819202122# Time complexity: O(n + m)# Space complexity: O(1)# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextclass Solution: def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -&gt; Optional[ListNode]: prehead = ListNode(-1) result = prehead while list1 and list2: if list1.val &lt;= list2.val: result.next = list1 list1 = list1.next else: result.next = list2 list2 = list2.next result = result.next result.next = list1 if list1 is not None else list2 return prehead.next]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Longest Common Prefix]]></title>
    <url>%2FLeetCode%2FLongest-Common-Prefix.html</url>
    <content type="text"><![CDATA[Longest Common PrefixQuestionExample 1: 12Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. SolutionHorizontal scanning 12345678910# Time Complexity: O(S), where S is the sum of all characters in all strings# Space Complexity: O(1)class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: prefix = strs[0] for s in strs: while s.find(prefix) != 0: prefix = prefix[0:-1] if prefix is None: return "" return prefix Vertical scanningImagine a very short string is the common prefix at the end of the array. The above approach will still do SS comparisons. One way to optimize this case is to do vertical scanning. We compare characters from top to bottom on the same column (same character index of the strings) before moving on to the next column. 12345678910111213# Time Complexity: O(S), where S is the sum of all characters in all strings# Even though the worst case is still the same as Approach 1, # in the best case there are at most n minLen comparisons # where minLen is the length of the shortest string in the array.# Space Complexity: O(1)class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if strs is None or len(strs) == 0: return "" for i in range(len(strs[0])): for j in range(1, len(strs)): if i == len(strs[j]) or strs[j][i] != strs[0][i]: return strs[0][0:i] return strs[0] Divide and conquer 12345678910111213141516171819class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: return self.longestCommonPrefixHelper(strs, 0, len(strs) - 1) def longestCommonPrefixHelper(self, strs: List[str], l: int , r: int): if l == r: return strs[l] else: mid = (l + r) // 2 lcpLeft = self.longestCommonPrefixHelper(strs, l, mid) lcpRight = self.longestCommonPrefixHelper(strs, mid + 1, r) return self.commonPrefix(lcpLeft, lcpRight) def commonPrefix(self, left: str, right: str): minLen = min(len(left), len(right)) for i in range(minLen): if left[i] != right[i]: return left[0:i] return left[0:minLen] Binary search 12345678910111213141516171819202122class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if strs is None or len(strs) == 0: return "" minLen = len(strs[0]) for s in strs: minLen = min(minLen, len(s)) low = 1 high = minLen while low &lt;= high: middle = (low + high) // 2 if self.isCommonPrefix(strs, middle): low = middle + 1 else: high = middle - 1 return strs[0][0:(low + high) // 2] def isCommonPrefix(self, strs: List[str], middle: int): str1 = strs[0][0:middle] for i in range(1, len(strs)): if not strs[i].startswith(str1): return False return True]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Integer to Roman]]></title>
    <url>%2FLeetCode%2FInteger-to-Roman.html</url>
    <content type="text"><![CDATA[Roman To IntegerQuestionExample 1:123Input: s = &quot;III&quot;Output: 3Explanation: III = 3. Example 2:123Input: s = &quot;LVIII&quot;Output: 58Explanation: L = 50, V= 5, III = 3. Example 3:123Input: s = &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. SolutionLeft-to-Right Pass1234567891011121314151617181920212223242526# Time O(1)# Space O(1)values = &#123; "I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000,&#125;class Solution: def romanToInt(self, s: str) -&gt; int: total = 0 i = 0 while i &lt; len(s): # If this is the subtractive case. if i + 1 &lt; len(s) and values[s[i]] &lt; values[s[i + 1]]: total += values[s[i + 1]] - values[s[i]] i += 2 # Else this is NOT the subtractive case. else: total += values[s[i]] i += 1 return total Left-to-Right Pass Improved12345678910111213141516171819202122232425262728293031# Time O(1)# Space O(1)values = &#123; "I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000, "IV": 4, "IX": 9, "XL": 40, "XC": 90, "CD": 400, "CM": 900&#125;class Solution: def romanToInt(self, s: str) -&gt; int: total = 0 i = 0 while i &lt; len(s): # This is the subtractive case. if i &lt; len(s) - 1 and s[i:i+2] in values: total += values[s[i:i+2]] i += 2 else: total += values[s[i]] i += 1 return total Right-to-Left Pass123456789101112131415161718192021# Time O(1)# Space O(1)values = &#123; "I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000,&#125;class Solution: def romanToInt(self, s: str) -&gt; int: total = values.get(s[-1]) for i in reversed(range(len(s) - 1)): if values[s[i]] &lt; values[s[i + 1]]: total -= values[s[i]] else: total += values[s[i]] return total Integer to RomanQuestionExample 1:123Input: num = 3Output: "III"Explanation: 3 is represented as 3 ones. Example 2:123Input: num = 58Output: "LVIII"Explanation: L = 50, V = 5, III = 3. Example 3:123Input: num = 1994Output: "MCMXCIV"Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. SolutionSolution 112345678910111213# Time O(1)# Space O(1)class Solution: def intToRoman(self, num: int) -&gt; str: digits = [(1000, "M"), (900, "CM"), (500, "D"), (400, "CD"), (100, "C"), (90, "XC"), (50, "L"), (40, "XL"), (10, "X"), (9, "IX"), (5, "V"), (4, "IV"), (1, "I")] roman_digits = [] for value, symbol in digits: if num == 0: break count, num = divmod(num, value) # divmod(7, 2) ----&gt; (3, 1) roman_digits.append(symbol * count) return ''.join(roman_digits)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Notes 3]]></title>
    <url>%2FBackend%2FJava%2FJava-Notes-3.html</url>
    <content type="text"><![CDATA[Functional ProgrammingImperative CodeEarly Java programs were usually programmed in the imperative style. Imperative code usually focuses on how a task is performed. Each line of code gives a specific procedure or operation: 12345678int getTopScore(List&lt;Student&gt; students) &#123; int topScore = 0; for (Student s : students) &#123; if (s == null) continue; topScore = Math.max(topScore, s.getScore()); &#125; return topScore;&#125; Focuses on how a task is performed. Each line of code gives a specific procedure or operation. Functional CodeStarting with version 8, Java added language features to support a more functional style of programming. You might also hear some people call it declarative programming. Functional code focuses on what happens to inputs in order to produce outputs. You can think of it as describing how to get from the input to the output: 1234567int getTopScore(List&lt;Student&gt; students) &#123; return students.stream() .filter(Objects::nonNull) .mapToInt(Student::getScore) .max() .orElse(0);&#125; This code does the exact same thing as the last code example, but it uses a more functional programming style, because it: Focuses on what happens to inputs in order to produce outputs.. Describes how to transform the input into the output. Lambda Expressions1234BinaryOperator&lt;Integer&gt; add = (Integer a, Integer b) -&gt; &#123; return a + b; &#125;;System.out.println(add.apply(1, 2)); Functional InterfaceA functional interface is a Java interface with exactly one abstract method, called the functional method. 1234567@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t); default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t); &#125; // Other methods left out of this example&#125; Predicate‘s one abstract method is test(). test() is known as the functional method. “Abstract” means the method is not implemented, so in order to be a functional method, it cannot have a default implementation. However, functional interfaces can have other default methods. In this case, the Predicate interface has a default method called negate() that returns another Predicate. Anonymous ClassAn anonymous class is a class that is defined “in-line” and has no name, and so it is called “anonymous”. Anonymous Class vs. LambdaThis anonymous class… 1234567Predicate&lt;String&gt; anonymousSubclass = new Predicate&lt;String&gt;() &#123; @Override public boolean test(String s) &#123; return s.trim().isEmpty(); &#125; &#125;; … does the same thing as this lambda expresssion: 1Predicate&lt;String&gt; lambdaInstead = s -&gt; s.trim().isEmpty(); Anonymous Class Lambdas Class generated at compile-time Class generated at runtime Can override equals()/hashCode() Cannot override them; has no identity this refers to the anonymous class this refers to the enclosing class What’s this all about?12345678910111213141516public final class ThisExample &#123; private final Runnable withLambda = () -&gt; System.out.println("From lambda: " + this.getClass()); private final Runnable withSubclass = new Runnable() &#123; @Override public void run() &#123; System.out.println("From subclass: " + this.getClass()); &#125; &#125;; public static void main(String[] args) &#123; ThisExample thisExample = new ThisExample(); thisExample.withLambda.run(); thisExample.withSubclass.run(); &#125;&#125; 12From lambda: class com.udacitydemo.lambdas.ThisExampleFrom subclass: class com.udacitydemo.lambdas.ThisExample$1 Inside the lambda, this.getClass() returns the class object representing ThisExample. We’ll cover class objects in more detail in the lesson on reflection, but for now the important part is that the this keyword inside the lambda references the enclosing class, which is com.udacitydemo.lambdas.ThisExample. For the Runnable subclass, on the other hand, the program printed com.udacitydemo.lambdas.ThisExample$1. You can see that the Java compiler generated a class called com.udacitydemo.lambdas.ThisExample$1 for the anonymous lambda (yes, the class name contains a dollar sign), and the this keyword refers to that generated class! If you compile this program yourself, you’ll even notice the Java compiler produces a file called ThisExample$1.class, which contains the compiled byte code for the anonymous class. Shortcomings of LambdasLambdas are very useful, but they do have some shortcomings: They can only be used to implement functional interfaces, not classes. Lambdas cannot implement any interface that has multiple abstract methods. Lambdas cannot throw checked exceptions (any subclass of Exception, such as IOException). Two ExamplesExample 1BinaryOperation.java1234@FunctionalInterfacepublic interface BinaryOperation&lt;T&gt; &#123; T apply(T a, T b);&#125; Main.java123456public final class Main &#123; public static void main(String[] args) &#123; BinaryOperator&lt;Integer&gt; add = (a, b) -&gt; a + b; assert 5 == add.apply(2, 3); &#125;&#125; Example 2Calculator.java123456789101112131415import java.util.HashMap;import java.util.Map;import java.util.function.BinaryOperator; // a functional interfacepublic final class Calculator &#123; private final Map&lt;String, BinaryOperator&lt;Integer&gt;&gt; operators = new HashMap&lt;&gt;(); public void registerOperation(String symbol, BinaryOperator&lt;Integer&gt; operator) &#123; operators.put(symbol.strip(), operator); &#125; public int calculate(int a, String operator, int b) &#123; return operators.get(operator).apply(a, b); &#125;&#125; Calculate.java1234567891011121314151617181920public final class Calculate &#123; public static void main(String[] args) &#123; if (args.length != 3) &#123; System.out.println("Usage: Calculate [int] [operator] [int]"); return; &#125; Calculator calculator = new Calculator(); calculator.registerOperation("+", (a, b) -&gt; a + b); calculator.registerOperation("-", (a, b) -&gt; a - b); calculator.registerOperation("/", (a, b) -&gt; a / b); calculator.registerOperation("*", (a, b) -&gt; a * b); int a = Integer.parseInt(args[0]); String operator = args[1]; int b = Integer.parseInt(args[2]); System.out.println(calculator.calculate(a, operator, b)); &#125;&#125; Capturing variablesCaptured variablesLambdas can capture variables from the surrounding code. If a lambda uses any variables from the surrounding code, those variables are captured. Variables can only be captured if they are effectively final. An effectively final variable is a variable whose value does not change after it is initialized. Example12345678Map&lt;Year, Integer&gt; getClassSizes(List&lt;Student&gt; students) &#123; final Map&lt;Year, Integer&gt; classSizes = new HashMap&lt;&gt;(); students.stream().forEach(s -&gt; classSizes.compute( s.getGraduationYear(), (k, v) -&gt; (v == null) ? 1 : 1 + v)); return classSizes;&#125; A good test to figure out if a variable is effectively final is to add the final keyword to it. If the code still compiles, that variable is effectively final! In the example, the classSizes variable is effectively final because the value of the variable itself does not change after it’s initialized. Remember that in Java, objects are passed by reference. Even though the HashMap changes, the variable’s value is the HashMap‘s location in memory, and that location never changes. Method ReferenceA method reference is a short lambda expression that refers to a method that is already named. Generally speaking, if a method is already defined that you can use, you should use a method reference instead of writing a brand new lambda. It’s usually a good idea in software development to not write new code if there’s already existing code that does the same thing you’re trying to do! Method references cannot capture surrounding variables, though. If you find yourself in this situation, you should use a custom lambda instead. 1234567891011121314151617181920212223242526272829import java.util.List;import java.util.function.Predicate;public final class LambdasMain &#123; /** * Returns the number of strings that match a given condition. * * @param input the strings that should be tested. * @param condition the condition that strings should be tested against. * @return the number of strings in the input that match the condition. */ public static long countMatchingStrings(List&lt;String&gt; input, Predicate&lt;String&gt; condition) &#123; return input.stream().filter(condition).count(); &#125; public static void main(String[] args) &#123; List&lt;String&gt; input = List.of("hello", "\t ", "world", "", "\t", " ", "goodbye", " "); // Using lambda expression: long numberOfWhitespaceStrings = countMatchingStrings(input, s -&gt; s.trim().isEmpty()); // Using method reference: long numberOfWhitespaceStrings = countMatchingStrings(input, String::isBlank); System.out.println(numberOfWhitespaceStrings + " whitespace strings"); &#125;&#125; Stream APIA stream is a sequence of elements. Streams are useful because they allow us to process collection, one element at a time. They can process elements in many ways, such as (but not limited to) filtering or transforming elements, sorting elements, or computing statistics such as the sum or average. A stream pipeline consists of creating a stream, calling intermediate operations on the stream, and then terminating the stream using a terminal operation. Example1234567void printScores(List&lt;Student&gt; students) &#123; return students.stream() .filter(Objects::nonNull) .mapToInt(Student::getScore) .max() .orElse(0);&#125; First, the stream() method creates a stream from the students list. This stream pipeline has two intermediate methods: the filter() method removes the elements of the stream that are null, and mapToInt() transforms each student into an int. Notice that each of these methods returns another Stream: filter() returns a Stream&lt;Student&gt;, and mapToInt() returns an IntStream. Finally, the terminal operation max() computes the maximum value in the IntStream. This terminal method actually returns an OptionalInt instead of an int. If the students parameter is empty or contains only null elements, it’s possible the final stream will be empty. In this case, we need to tell the program to return a default value of 0. If max() returns an OptionalInt with a value, that value will be used. However, if max() returns OptionalInt.empty(), the call to orElse() makes sure that a default value of 0 will be returned. CollectorA Collector is a terminal stream operation that accumulates stream elements into a container. The collect() method is a terminal operation that aggregates streams of elements. Collectors can be passed to collect() to determine what kind of collection is created. 1Set&lt;String&gt; s = stringList.stream().collect(Collectors.toSet()); Collectors can be used to perform reduction operations such as adding or counting. 123Map&lt;Year, Long&gt; graduatingClassSizes = studentList.stream() .collect(Collectors.groupingBy( Student::getGraduationYear, Collectors.counting()); Here, groupingBy() is used to collect elements into a Map. Collectors.counting() counts the number of values for each key, so, in this example, it will count how many students there are for each graduation year.]]></content>
      <categories>
        <category>Backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add Binary]]></title>
    <url>%2FLeetCode%2FAdd-Binary.html</url>
    <content type="text"><![CDATA[QuestionGiven two binary strings a and b, return their sum as a binary string. Example 1:12Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot; Example 2:12Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot; SolutionSolution 11234# O(M+N)class Solution: def addBinary(self, a, b) -&gt; str: return '&#123;0:b&#125;'.format(int(a, 2) + int(b, 2)) 123456# 二进制字符串转十进制int(“11”, 2) # 3# 把十进制数12转为对应的二进制数的字符串形式'&#123;0:b&#125;'.format(12) '1100' 1 . In Java this approach is limited by the length of the input strings a and b. Once the string is long enough, the result of conversion into integers will not fit into Integer, Long or BigInteger. 2 . This method has quite low performance in the case of large input numbers. Solution 21234567891011121314151617181920212223242526# Time O(max(M,N))# Space O(max(N,M))class Solution: def addBinary(self, a, b) -&gt; str: n = max(len(a), len(b)) # zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0 a, b = a.zfill(n), b.zfill(n) carry = 0 answer = [] for i in range(n - 1, -1, -1): if a[i] == '1': carry += 1 if b[i] == '1': carry += 1 if carry % 2 == 1: answer.append('1') else: answer.append('0') carry //= 2 # 最后一位的进位 if carry == 1: answer.append('1') # append 方法获得的数据结果需要反向，并将字符串连接到一起 answer.reverse() return ''.join(answer) Solution 3Here the input is more adapted to push towards Approach 1, but there is popular Facebook variation of this problem when interviewer provides you two numbers and asks to sum them up without using addition operation. How to start? There is an interview tip for bit manipulation problems: if you don’t know how to start, start from computing XOR for your input data. 12345678class Solution: def addBinary(self, a, b) -&gt; str: x, y = int(a, 2), int(b, 2) while y: answer = x ^ y carry = (x &amp; y) &lt;&lt; 1 x, y = answer, carry return bin(x)[2:] # bin()将十进制转二进制 123# 结果的前两位需要去掉&gt;&gt;&gt;bin(10)'0b1010']]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Design Pattern]]></title>
    <url>%2FBackend%2FDesign-Pattern.html</url>
    <content type="text"><![CDATA[一个设计模式非常好的网站 设计模式简介设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 设计模式的类型总共有 23 种设计模式。这些模式可以分为三大类： 创建型模式（Creational Patterns） 结构型模式（Structural Patterns） 行为型模式（Behavioral Patterns） 创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） 结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） 行为型模式这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern）]]></content>
      <categories>
        <category>Backend</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Notes 2]]></title>
    <url>%2FBackend%2FJava%2FJava-Notes-2.html</url>
    <content type="text"><![CDATA[Common TypesExceptionsThe Error Class and the Exception ClassThe Java error-handling framework uses two different classes to identify abnormal software events: The Error class is used to indicate a serious problem that the application should not try to handle. The Exception class is used when there is a less catastrophic event that the application should try to handle. The Throwable ClassBoth Error and Exception classes inherit from the abstract class throwable. This means that both errors and exceptions will contain: The type of problem – the class type, either Exception or Error The problem message – whatever description you’ve provided within the class, such as “out of memory” The stack trace where the exception occurred – the order in which things ran and the place in that sequence where the problem occurred (this information is used by developers to track down issues and resolve problems in the code) Throwing an ExceptionWhat does it mean to throw an exception? When an error occurs within a method, that method creates an Exception object. Next, the method hands the Exception off to the JVM runtime system. And that’s what we mean when we say that we are throwing an exception. We simply mean that a method hands off an exception to the runtime. Checked vs UncheckedIn Java there are two different types of exceptions: Unchecked Exceptions Unchecked exceptions are exceptions that are unknown to the compiler. Because these exceptions are only known at runtime, they are also referred to as runtime exceptions. They are a result of a programming error, typically arithmetic errors (such as division by 0). Unchecked exceptions are used when when we expect that the caller of the method cannot recover from the exception. Checked Exceptions Checked exceptions are known to the compiler. If we are calling a method that potentially throws a checked exception, it must be handled (or we will get an error from the compiler). Checked exceptions are used when we expect that the caller of the method can recover from the exception. Handling Exceptions12345678try &#123; read();&#125;catch (FileNotFoundException ex)&#123; ex.getLocalizedMessage();&#125;finally &#123;&#125; EnumIn Java, the declaration of an Enum defines a class. This class can exist within another class or as a standalone class. In some cases, we might only need to use the Enum type within a single class (as would probably be the case with the stoplight example). In that case it would be acceptable to define it within another class rather than as a standalone. However, if other classes are expected to use the enum type, it should be defined as a separate, standalone class. 123456789101112public class Main &#123; enum StopLight &#123; RED, YELLOW, GREEN &#125; public static void main(String[] args) &#123; StopLight myStoplight = Stoplight.RED; System.out.println(myStoplight); &#125;&#125; ScannerThe Scanner class can read and parse simple text. Here are some key points to keep in mind: It parses primitive types and String types into tokens. By default it uses whitespaces to delimitate each word. However, it can also use regular expressions. The Scanner class can read from several different types of sources, like strings, files and System.in (to get input from the command line). Scanner SyntaxExample 1We can use the Scanner class to get input from the command line. To do so, we instantiate a scanner object, passing in System.in: 1Scanner scanner = new Scanner(System.in); Example 2In this example we are using the nextLine method to return the full line of the input: 12Scanner scanner = new Scanner("This is a line");System.out.println(scanner.nextLine()); Output: 1This is a line Example 3In this next example, we are using the next method to read the first token. The next method finds and returns the next complete token. 12Scanner scanner = new Scanner("This is a line");System.out.println(scanner.next()); Output: 1This Example 4In the final example, we are using the hasNext() method in a while loop to determine if it is safe to call the next method. We only want to call the next method when we know there is a token available. Note: By default the Scanner tokenizes input by whitespaces. Let’s say we have a string with the following text &quot;One Two Three&quot;. The text will be tokenized into three separate tokens, &quot;One&quot;, &quot;Two&quot; and &quot;Three&quot;. 12345Scanner scanner = new Scanner("This is a line");while(scanner.hasNext()) &#123; System.out.println(scanner.next());&#125; Output: 1234Thisisaline Scanner Example1234567891011121314151617181920import java.util.Scanner;public class UserInputTester &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); try &#123; System.out.println("Enter a String"); String userInput = scanner.nextLine(); System.out.println("User Input: " + userInput); &#125; catch (Exception ex) &#123; ex.getLocalizedMessage(); &#125; finally &#123; scanner.close(); // we have to close the scanner &#125; &#125;&#125; RegEx12345678910public class RegExTester &#123; public static void main(String[] args)&#123; String emailRegex = "^(.+)@(.+).(.+)$"; Pattern pattern = Pattern.compile(emailRegex); String email = "jeff@gmail.com"; System.out.println(pattern.matcher(email).matches()); &#125;&#125; StringJava provides advanced memory management for String objects by using a String pool. A String pool is a way of storing only one copy of a String. To understand this, we have to look at what is happening in memory when we create Strings and assign them to variables. Strings in Java are immutable, meaning they cannot be changed after they are created. When we “change” the String in a variable, what actually happens is that, behind the scenes, Java creates a new String in the String pool—and changes the variable’s reference value to point to this new String. The old String object may remain in place, unchanged. Also note that multiple variables may use the same String reference. This means that if we have two variables with exactly the same String (e.g., &quot;Hello&quot;) they will all reference the same String object. Generics and CollectionsGenericsWith generics, we can identify what types are stored in the list. The syntax for a generic is very simple—it’s just bracket with the type inside, &lt; type &gt;. So in this example, we can add &lt;String&gt; right next to List to identify what types are stored in the list: 123456789List&lt;String&gt; myList = new ArrayList&lt;String&gt;();myList.add("one");myList.add("two");myList.add("three");// We could also remove the element "one" // by using the index 0 instead of the value "one".myList.remove("one"); CollectionsUse iterator with collections12345678910List&lt;String&gt; names = new LinkedList&lt;String&gt;();names.add("Mike");names.add("Bob");names.add("Alice");Iterator&lt;String&gt; iterator = names.iterator();while(iterator.hasNext())&#123; System.out.println(iterator.next());&#125; for each loop1234567891011121314public class CollectionsExercise &#123; public static void main(String[] args) &#123; List&lt;String&gt; listOfItems = new LinkedList&lt;String&gt;(); listOfItems.add("Mike"); listOfItems.add("Bob"); listOfItems.add("Alice"); for (String name : listOfItems) &#123; System.out.println(name); &#125; &#125;&#125; Sorting collectionsStringsA list of Strings can be sorted by simply passing the list to the Collections.sort() method. In the example bellow, the names will be sorted in ascending order. 1234567List&lt;String&gt; names = new LinkedList&lt;String&gt;();names.add("Mike");names.add("Bob");names.add("Alice");Collections.sort(names); Wrapper ObjectsWrapper objects were introduced in Java to wrap primitive variable types into objects. In the example below, the primitive int values are being converted to Integer objects and then sorted. 1234567List&lt;Integer&gt; numbers = new LinkedList&lt;Integer&gt;();numbers.add(201);numbers.add(100);numbers.add(101);Collections.sort(numbers); User-Defined ClassesUser-defined classes will need to implement the Comparable Interface in order to use the Collections.sort() method. The Comparable Interface provides a method, compareTo, which is used to compare two objects of the same type. In the example below we are using the Person object’s name field to compare Person objects. This line of code, name.compareTo(person.name), handles all of the hard work. 1234567891011121314151617181920212223242526import java.util.*; class Person implements Comparable&lt;Person&gt; &#123; public String name; public Person(String name) &#123; this.name = name; &#125; // implement compareTo function public int compareTo(Person person) &#123; return name.compareTo(person.name); &#125; &#125; public class PersonSort &#123; public static void main(String[] args) &#123; ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;(); people.add(new Person("Same")); people.add(new Person("Mike")); people.add(new Person("Apple")); Collections.sort(people); for (Person person : people) &#123; System.out.println(person.name); &#125; &#125;&#125; Advanced CollectionsMapCreating a Map Object1Map&lt;String, Person&gt; mapOfPeople = new HashMap&lt;String, Person&gt;(); Adding to a Map123456789Person mike = new Person("Mike", "mike@email.com");Person shaun = new Person("Shaun", "shaun@email.com");Person sally = new Person("Sally", "sally@email.com");Person cesar = new Person("Cesar", "cesar@email.com");mapOfPeople.put(mike.getEmail(), mike);mapOfPeople.put(shaun.getEmail(), shaun);mapOfPeople.put(sally.getEmail(), sally);mapOfPeople.put(cesar.getEmail(), cesar); Retrieving an object from a MapIn this example, we will be looking at the syntax to retrieve a Person object from the Map using an email as the key. 1mapOfPeople.get("mike@email.com"); Iterating over a MapWe can iterate over our Map using a for-each loop. Remember that each Map has three distinct views for seeing the data. We can get the keys, the values, or key-value mapping. In the example below we are displaying all of the keys for our Map. 123for (String email : mapOfPeople.keySet()) &#123; System.out.println(email);&#125; Example12345678910111213141516171819202122232425262728293031323334353637383940public class MapExcercise &#123; public static void main(String[] args) &#123; Map&lt;String, Person&gt; mapOfPeople = new HashMap&lt;String, Person&gt;(); Person mike = new Person("Mike", "mike@email.com"); Person shaun = new Person("Shaun", "shaun@email.com"); Person sally = new Person("Sally", "sally@email.com"); Person cesar = new Person("Cesar", "cesar@email.com"); ArrayList&lt;Person&gt; people = new ArrayList&lt;Person&gt;(); people.add(mike); people.add(shaun); people.add(sally); people.add(cesar); for (Person person : people) &#123; MapExcercise.addToMap(mapOfPeople, person); &#125; for (String email : mapOfPeople.keySet()) &#123; System.out.println(email); &#125; for (Person person : mapOfPeople.values()) &#123; System.out.println(person); &#125; System.out.println("Get Mike: " + mapOfPeople.get("mike@email.com")); System.out.println("Get Jeff: " + mapOfPeople.get("jeff@email.com")); System.out.println("Contains Mike: " + mapOfPeople.containsKey("mike@email.com")); System.out.println("Contains Jeff: " + mapOfPeople.containsKey("jeff@email.com")); &#125; private static void addToMap(Map&lt;String, Person&gt; map, Person person) &#123; map.put(person.getEmail(), person); &#125;&#125; 123456789101112131415161718192021222324public class Person &#123; private final String name; private final String email; public Person(String name, String email) &#123; this.name = name; this.email = email; &#125; public String getName() &#123; return name; &#125; public String getEmail() &#123; return email; &#125; @Override public String toString() &#123; return name + " " + email; &#125;&#125; SetsConcrete ImplementationsThere are three concrete implementations for the Set interface: HashSet TreeSet LinkedHashSet Each of these implementations vary, but all of them enforce the no-duplicate-values requirement of the Set interface. Creating a Set Object1Set&lt;String&gt; mySet = new HashSet&lt;String&gt;(); Adding to a Set123mySet.add("Hello");mySet.add("Hello");mySet.add("Hellos"); Even though we used add three times, this will actually only add two items, since one of the items is a duplicate. Retrieving an Object From a SetUsing for each loop to retrieve an object. 1234567String foundObject;for (String text : mySet) &#123; if(text.equals("Hello")&#123; foundObject = text; &#125;&#125; Example1234567891011121314151617181920212223import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;public class SetExcercise &#123; public static void main(String[] args) &#123; List&lt;String&gt; numbers = new ArrayList&lt;String&gt;(); // We have a list of numbers and some are duplicates numbers.add("123-222-3333"); numbers.add("123-222-3333"); numbers.add("555-222-3333"); // Add them to a Set to get a unique list Set&lt;String&gt; uniqueNumbers = new HashSet&lt;String&gt;(numbers); for (String number : uniqueNumbers) &#123; System.out.println(number); &#125; &#125;&#125; QueuesQueues are data structures that allow us to process items in a First-In, First-Out (FIFO) order. The first item placed in a queue is also the first one removed from the queue. Some key points about Queues in Java: Queue is an interface that implements the Collection interface We put newly added elements at the end of the queue We pop elements off the front of the queue Creating a Queue object1Queue&lt;String&gt; myQueue = new LinkedList&lt;String&gt;(); Adding to a Queue12myQueue.add("Hi");myQueue.add("There"); Retrieving an Object From a QueueThis method both retrieves the first element from the Queue and removes it from the Queue. 1myQueue.poll() Iterating Over a Queue123while (!myQueue.isEmpty()) &#123; System.out.println(myQueue.poll());&#125; Supplementary KnowledgeSuper()We can use super() to call the direct parent constructor. 12345678910111213public abstract class ShapeDecorator implements Shape &#123; protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape) &#123; this.decoratedShape = decoratedShape; &#125; public void draw() &#123; decoratedShape.draw(); &#125;&#125; 1234567891011121314151617181920public class RedShapeDecorator extends ShapeDecorator &#123; public RedShapeDecorator(Shape decoratedShape) &#123; super(decoratedShape); // use super() to call the parent constructor // inheritate the decoratedShape // this.decoratedShape = decoratedShape; &#125; @Override public void draw() &#123; super.draw(); setRedBorder(this.decoratedShape); // use the decoratedShape &#125; // add a new function(decorate) private void setRedBorder(Shape decoratedShape) &#123; System.out.println("Border Color: Red"); &#125;&#125;]]></content>
      <categories>
        <category>Backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCD]]></title>
    <url>%2FiOS%2FGCD.html</url>
    <content type="text"><![CDATA[What is GCDGCD - ==Grand Central Dispatch== UIKit can only be used on main queue. Core data can be used both on main queue and background queue. But the core data can only be used in the same queue it was created. Or we will meet ==concurrency bugs==. 并发错误 async and sync Dispatch_async(): doesn’t wait for the closure to finish, and moves on. Dispatch_sync(): waits until the closure is done. Could easily get stalled. UserDefaultsUserDefaults: a Dictionary that periodically saves its contents to your device’s permanent storage (SSD). Great for storing user preferences and other simple things. Saves data in a plist file (property list file). Can only store the following data types: Data, String, Number, Date, Array, and Dictionary. When storing (writing) the file or accessing (reading) the file, UserDefaults does it all at once, possibly creating long/unnecessary I/O time. It’s a good idea to keep UserDefaults under 1MB. OptionalThe difference between Swift optionals and Core Data optional attributes is subtle. Swift optionals can be nil during runtime, and Core Data optional attributes can be nil at save time.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Notes]]></title>
    <url>%2FBackend%2FJava%2FJava%20Notes.html</url>
    <content type="text"><![CDATA[Java Programing BasicsJava is static typingNotice that, in Java, we must specify the data type (e.g., int). This is becouse Java is a statically typed language. Here are the key points to remember about static typing: The data type is bound to the variable when the variable is first declared. The data type is checked when the code is compiled. The data type for a variable cannot later be changed. In contrast, some languages, such as Python, are dynamically typed. In dynamic typing: The data type is bound to the value itself, but not to the variable. The type is checked during runtime. The data type of a variable can be changed after it is declared; since the type is associated with the value, assigning a new value may mean changing the data type. Hello world!123456789101112public class GettingStarted&#123; public static void main(String[] args) &#123; // Add your code here: System.out.println("Hello world!!"); &#125;&#125;// Use commond line to compile and runjavac GettingStarted.javajava GettingStarted.java Type castingAutomatic Type CastingAutomatic type casting converts a smaller type into a larger type. For example: 123int intNumber = 3;double doubleNumber = intNumber;System.out.println(doubleNumber); When we print doubleNumber, the value will be 3.0. Notice that there is no precision lost going from a smaller type into a larger type. We started with 3 and ended up with 3.0. Manual Type CastingManual type casting is necessary when we want to do either of these things: Convert a larger type into a smaller type Convert one object type into another For example, here we are converting from a larger type (double) to a smaller type (int): 123double doubleNumber = 3.5;int intNumber = (int)doubleNumber;System.out.println(intNumber); The resulting value will be 3, not 3.5. When we go from a larger type into a smaller type, precision is lost. Java cuts off additional data that will not fit in the casted type. So when we go from a double to an int, any values that are not integers will be removed. This is called truncation. MethodsMethod syntax1234public double findTheArea(double length, double width) &#123; double area = length * width; return area;&#125; Methods vs FunctionsYou’ll often see the words function and method used interchangeably. Although the terms are sometimes used loosely, here’s the distinction: A function is any block of reusable/callable code. A method is a block of reusable/callable code that is attached to a class or object. So a method is a type of function, but it’s one that is associated with a class or object, whereas other functions can be executed from anywhere. Stack and Heap Types of Access ModifiersThere are four types of access modifiers in Java: Public means the class can be accessed from everywhere. If you have a method on a class that you want to expose to all other classes, then use this access modifier. Private means only the defining class can access the data. This provides security, by not allowing other classes to change the data directly. Instead, they must make changes to the data via the provided methods only. Protected means that access is restricted to the defining class, package, or subclass. This will be useful when we get into subclasses and inheritance in a later lesson, as it will allow our subclasses to use variables and methods from the parent class. Default means access is restricted to the defining class or the package. This can be used when we have classes inside the same package that we may want to expose data and methods too. Access Inside class Inside package Outside package by subclass Outside package Private Yes No No No Default Yes Yes No No Protected Yes Yes Yes No Public Yes Yes Yes Yes ArrayCreating an ArrayHere’s an example of some code that creates an array of size four, containing four integer values: 1int [] numbers = &#123;1, 2, 3, 4&#125;; Notice that creating an array involves three steps: Declare the type of the array, using brackets (as in int []). Name the array (in this example, the name is numbers). Add values to the array. Another Way to Create an ArrayHere’s another way we can create an array and add values to it: 1234567int [] numbers = new int[4];numbers[0] = 1;numbers[1] = 2;numbers[2] = 3;numbers[3] = 4;int[] numbers = new int[] &#123; 1, 2, 3, 4 &#125;; This approach uses the new keyword to create a new array object of size 4, and then we assign values to the four spaces created in the array. Loop12345678910111213141516171819202122232425262728public class LoopExercise &#123; public static void main(String[] args) &#123; int[] numbers = new int[] &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; // Add for Loop Here for (int i = 0; i &lt; numbers.length; i++) &#123; System.out.println(numbers[i]); &#125; // Add while Loop Here int index = 0; while (index &lt; numbers.length) &#123; System.out.println(numbers[index]); index++; &#125; // Add Do while Loop Here int counter = 0; do &#123; System.out.println(numbers[counter]); counter++; &#125; while (counter &lt; numbers.length); &#125;&#125; DocumentationSyntaxJavaDoc comments use a simple syntax that supports multi-line HTML format documentation. Here’s what the syntax looks like: 1/** documentation */ And here’s an example: 123456/** This program HelloWorld produces a standard output * displaying "Hello World" * * @author The author of the class * @see A reference to another class */ Parts of a JavaDoc CommentNotice that JavaDoc comments are broken down into two parts: The description Block tags In the above example, the description is the first part of the comment, and the block tags are the last part (@author and @see). In this example, we have a doc comment for a method: 12345678/** * This method displays a simple text output to a provided name * * * @param name The name of the person we want to say “Hi” too * @return results Returns true if the name was printed or * false if it failed */ Objecte-Oriented ProgrammingDefine a class12345678910111213141516171819202122public class Person &#123; private String firstName; private String lastName; public Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125; public String getFirstName() &#123; return this.firstName; &#125; public String getLastName() &#123; return this.lastName; &#125; @Override public String toString() &#123; return this.firstName + " " +this.lastName; &#125;&#125; Garbage CollectionEvery new object that we instantiate is added to the heap and consumes memory. In programming languages like C or C++, developers are responsible for creating and destroying objects. In contrast, Java has a background process called Garbage Collection (GC) that checks all instantiated objects, and destroys them if they do not have any references—thus freeing up memory, even without any active management on the part of the developer. Abstract ClassesAn abstract class has the following key characteristics: It defines the behavior for each of the subclasses, but we cannot directly instantiate the abstract class itself. It allows us to create abstract methods An abstract method is a method that does not contain an implementation body. Instead, it simply provides a header for the method. Subclasses that extend an abstract class are required to override all abstract methods and provide a specific implementation. Example: Abstract Vehicle ClassHere’s the example we looked at in the video. To ensure that we will not be able to directly instantiate Vehicle objects from this class, we define it using the abstract keyword: 1234567891011121314public abstract class Vehicle &#123; protected String start; protected String stop; protected String direction; public Vehicle(String start, String stop, String direction) &#123; this.start = start; this.stop = stop; this.direction = direction; &#125; public abstract void speed(); &#125; Next, we use the Extends keyword to have our Car class extend the Vehicle class: 12345678910public class Car extends Vehicle &#123; public Car() &#123; super("Car start", "Car stop", "Car direction"); &#125; @Override public void speed() &#123; System.out.println("55"); &#125;&#125; InterfacesInterfaces allow us to avoid hardcoding features in an application. We can move specific implementation details into subclasses, and then use an interface to communicate between the application and the subclasses. A website about interface. Interfaces vs Abstract ClassesHere are some of the similarities and differences between abstract classes and interfaces: Abstract class Can have class variables. Can have both abstract methods and concrete methods that are shared with the subclasses. Can have instance variables, i.e. variables that are specific to individual subclasses. Subclasses can only extend one class. Interfaces Can have class variables. Every method in an interface is abstract. Cannot have instance variables. Variables in an interface must be the same for every class implementing the interface. Classes can implement more than one interface and have multiple inheritance. One other thing to note is that that Interfaces are types just like classes are types! 123456789public interface Vehicle &#123; public String getType(); public String getSpeed(); public String getColor();&#125; 12345678910111213141516171819202122232425262728public class Car implements Vehicle &#123; private String type; private String speed; private String color; public Car(String type, String speed, String color) &#123; super(); this.type = type; this.speed = speed; this.color = color; &#125; @Override public String getType() &#123; return type; &#125; @Override public String getSpeed() &#123; return speed; &#125; @Override public String getColor() &#123; return color; &#125;&#125;]]></content>
      <categories>
        <category>Backend</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git]]></title>
    <url>%2FOtherTechnique%2FGit.html</url>
    <content type="text"><![CDATA[How to use GitHere are some commonds to use git. 12git initgit pull 1234git add .git commit -m &apos;&apos;git pushgit pull 12345678git branch # show the local branch git branch -a # show all the branch including the remote branchgit checkout branchName # change to the local branchgit checkout -b localBranchName origin/remoteBranchName # create a new local branch the same as the remote branchgit merge branchName # merge the current branch with another branchgit branch -d branchName # delete the local branchgit push origin --delete remoteBranchName # delete the remote branch]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network Foundations HTTP]]></title>
    <url>%2FiOS%2FNetwork-Foundations-HTTP.html</url>
    <content type="text"><![CDATA[Networking Terms Data: (Usually in the raw form) anything that is sent over the network. Client: Server: URL: Uniform Resource Locator HTTP: Hypertext Transfer Protocol HTTPS: HTTP Secure, Anatomy of a URL Component Name https:// scheme swift.org host /about/ path Order Component 1st scheme 2nd host 3rd port 4th path 5th query 6th fragment Status codesHTTP status codes fall into 5 ranges based on the type of response. 100: Informational response (request has been received by the server but is not finished yet) 200: Successful response (request has been processed and completed by the server) 300: Redirection (client needs to do something to complete the request) 400: Unsuccessful (problem with the client’s request) 500: Unsuccessful (problem with the server) A complete list of status codes can be found here. Status Code Short Description Category 100 Continue Information 200 OK Success 301 Moved Permanently Redirection 403 Forbidden Client Error 404 Not Found Client Error 418 I’m a teapot Client Error 500 Internal Server Error Server Error HTTP VerbsCRUD: Create Read Update Delete Verb CRUD Operation GET Read POST Create PUT Update(Replace) PATCH Update(Modify) DELETE Delete GET: Retrieves data from the server, such as getting a list of search results. POST: Submits data to be stored in the server, such as when submitting a form. PUT: Updates data on the server, replacing the old data with the new data. PATCH: Updates data on the server, by changing specific values. DELETE: Used when removing data from the server. URLstring123456789101112// Task 1: create a valid URLlet website = "http://udacity.com"let url = URL(string: website)print(url!)// Task 2: append an "ios" path component to the URLurl?.appendPathComponent("ios")if let url = url &#123; print("URL: \(url)")&#125; We can’t add query and fragment. URLComponents12345678910111213141516import Foundation// create a new URLComponentsvar components = URLComponents()// set the schemecomponents.scheme = "https"// set the hostcomponents.host = "google.com"// set the pathcomponents.path = "/search"// set the query, you'll need to create a new URLQueryItemcomponents.queryItems = [URLQueryItem(name: "query", value: "udacity")]print(components.url ?? "") Use struct to store URLComponents1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import Foundationlet urlString = "https://itunes.apple.com/us/app/udacity/id819700933?mt=8"let urlComponents = URLComponents(string: urlString)if let urlComponents = urlComponents &#123; print("scheme:\t\t\(String(reflecting: urlComponents.scheme))") print("user:\t\t\(String(reflecting: urlComponents.user))") print("password:\t\(String(reflecting: urlComponents.password))") print("host:\t\t\(String(reflecting: urlComponents.host))") print("port:\t\t\(String(reflecting: urlComponents.port))") print("path:\t\t\(String(reflecting: urlComponents.path))") print("query:\t\t\(String(reflecting: urlComponents.query))") print("fragment:\t\(String(reflecting: urlComponents.fragment))")&#125;struct AppStore &#123; static let scheme = "https" static let host = "itunes.apple.com" static let udacityPath = "/us/app/udacity/id819700933" enum ParameterKey: String &#123; case mediaType = "mt" &#125; enum MediaType: String &#123; case music = "1", podcasts = "2", audiobooks = "3", tvShows = "4", musicVideos = "5", movies = "6", iPodGames = "7", mobileApps = "8", ringTones = "9", iTunesU = "10", ebooks = "11", desktopApps = "12" &#125;&#125;var udacityAppURL = URLComponents()udacityAppURL.scheme = AppStore.schemeudacityAppURL.host = AppStore.hostudacityAppURL.path = AppStore.udacityPathudacityAppURL.queryItems = [URLQueryItem(name: AppStore.ParameterKey.mediaType.rawValue, value: AppStore.MediaType.mobileApps.rawValue)]print(udacityAppURL) URLSession“Tasks” are what URLSession calls network requests. URLSessionDataTask: Used for perfuming an HTTP request (GET, POST, etc.). URLSessionDownloadTask: Downloading a file from a server. URLSessionUploadTask: Uploading a file to a server URLSessionStreamTask: Getting a continuous stream of data from a server. After you create the task, you must start it by calling its resume() method. Newly-initialized tasks begin in a suspended state, so you need to call this method to start the task. ###URLSession.shared.dataTask 123456789101112131415161718192021@IBAction func loadImage(_ sender: Any) &#123; guard let url = URL(string: self.imageLocation) else &#123; print("Cannot create url!") return &#125; let task = URLSession.shared.dataTask(with: url) &#123; (data, response, error) in guard let data = data else &#123; print("no data") return &#125; let downLoadedImage = UIImage(data: data) // the code of network request is working on the background // have to move this line of code to the main thread DispatchQueue.main.async &#123; self.imageView.image = downLoadedImage &#125; &#125; // have to use resume() to start the task task.resume() &#125; Trailing closure syntaxMany functions in iOS accept multiple parameters where the final parameter is a closure. 12345678let task = URLSession.shared.dataTask(with: url, completionHandler: &#123; &#125;)// trailing closure syntaxlet task = URLSession.shared.dataTask(with: url) &#123; &#125; URLSession.shared.downloadTask123456789101112131415161718@IBAction func loadImage(_ sender: Any) &#123; guard let url = URL(string: self.imageLocation) else &#123; print("Cannot create url!") return &#125; let task = URLSession.shared.downloadTask(with: url) &#123; (location, response, error) in guard let location = location else&#123; print("location is nil!") return &#125; let downLoadedImage = try! Data(contentsOf: location) DispatchQueue.main.async &#123; self.imageView.image = UIImage(data: downLoadedImage) &#125; &#125; task.resume() &#125; APIAPI &amp; Web ServiceThere you have it: an API is an interface that allows you to build on the data and functionality of another application, while a web service is a network-based resource that fulfills a specific task. Yes, there’s overlap between the two: all web services are APIs, but not all APIs are web services. DogAPIJSONSerialization123456789class DogAPI &#123; enum endpoint: String &#123; case randomImageFromAllDogsCollection = "https://dog.ceo/api/breeds/image/random" var url: URL &#123; return URL(string: self.rawValue)! &#125; &#125;&#125; 123456789101112131415let randomImageEndpoint = DogAPI.endpoint.randomImageFromAllDogsCollection.url let tast = URLSession.shared.dataTask(with: randomImageEndpoint) &#123; data, response, error in guard let data = data else &#123; return &#125; do &#123; let json = try JSONSerialization.jsonObject(with: data, options: []) as! [String: Any] let url = json["message"] as! String print(url) &#125; catch &#123; print(error) &#125;&#125;tast.resume() Codable1234struct DogImage: Codable &#123; let status: String let message: String&#125; 123let decoder = JSONDecoder()let imageData = try! decoder.decode(DogImage.self, from: data)print(imageData) // a struct JSON parsing scenarios Coding Keys (a way to map differently named JSON keys to Swift property names) Parsing JSON Arrays Nested JSON objects Accessing keys and values (treating a JSON object like a dictionary when we don’t know what the keys and values will be) Coding Keys12345678910111213141516171819202122232425262728293031import Foundationvar json = """&#123; "food_name": "Lemon", "taste": "sour", "number of calories": 17&#125;""".data(using: .utf8)!struct Food: Codable &#123; let name: String let taste: String let calories: Int enum CodingKeys: String, CodingKey &#123; case name = "food_name" case taste case calories = "number of calories" &#125;&#125;let decoder = JSONDecoder()let food: Fooddo &#123; food = try decoder.decode(Food.self, from: json) print(food)&#125; catch &#123; print(error)&#125; Parsing JSON Arrays1234567891011121314151617181920212223242526272829303132import Foundationvar json = """[ &#123; "title": "Groundhog Day", "released": 1993, "starring": ["Bill Murray", "Andie MacDowell", "Chris Elliot"] &#125;, &#123; "title": "Home Alone", "released": 1990, "starring": ["Macaulay Culkin", "Joe Pesci", "Daniel Stern", "John Heard", "Catherine O'Hara"] &#125;]""".data(using: .utf8)!struct Movie: Codable &#123; let title: String let released: Int let starring: [String]&#125;let decoder = JSONDecoder()let comedies: [Movie]do &#123; comedies = try decoder.decode([Movie].self, from: json) print(comedies)&#125; catch &#123; print(error)&#125; Nested JSON objects123456789101112131415161718192021222324252627282930313233import Foundationvar json = """&#123; "name": "", "studentId: 326156, "academics": &#123; "field": "iOS", "grade": "A" &#125;&#125;""".data(using: .utf8)!struct Academics: Codable &#123; let field: String let grade: String&#125;struct Student: Codable &#123; let name: String let studentId: String let academics: Academics&#125;let decoder = JSONDecoder()let student: Studentdo &#123; student = try decoder.decode(Student.self, from: json) print(student)&#125; catch &#123; print(error)&#125; Accessing keys and values12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import Foundationlet json = """&#123; "100": &#123; "type": "colonial", "location": "Plainville, MA", "bedrooms": 3, "bathrooms": 2.5, "has air conditioning": false, "amenities": ["basement", "garden"], "listing": &#123; "price": 430000, "date": "May 2018" &#125; &#125;, "101": &#123; "type": "condo", "location": "San Francisco, CA", "bedrooms": 1, "bathrooms": 1, "has air conditioning": true, "amenities": [], "listing": &#123; "price": 765000, "date": "September 2018" &#125; &#125;&#125;""".data(using: .utf8)!struct Listing: Codable &#123; let price: Int let date: String&#125;struct House: Codable &#123; let houseType: String let location: String let beds: Int let baths: Float let hasAirConditioning: Bool let amenities: [String] let listing: Listing enum CodingKeys: String, CodingKey &#123; case houseType = "type" case location = "location" case beds = "bedrooms" case baths = "bathrooms" case hasAirConditioning = "has air conditioning" case amenities case listing &#125;&#125;let decoder = JSONDecoder()do &#123; let houseDict = try decoder.decode([String: House].self, from: json) print(houseDict) let houses = houseDict.values.map(&#123;$0&#125;) let houseIds = houseDict.keys.map(&#123;$0&#125;) print(houses) print(houseIds)&#125; catch &#123; print(error)&#125; We have to use map to transform the data from keys type to array type. Post request in Swift1234567891011121314151617181920212223242526272829303132import Foundationimport CoreFoundation// create a Codable struct called "POST" with the correct propertiesstruct Post: Codable &#123; let userId: Int let title: String let body: String&#125;// create an instance of the Post struct with your own valueslet post = Post(userId: 1, title: "udacity", body: "udacious")// create a URLRequest by passing in the URLvar request = URLRequest(url: URL(string: "https://jsonplaceholder.typicode.com/posts")!)// set the HTTP method to POSTrequest.httpMethod = "POST"// set the HTTP body to the encoded "Post" structrequest.httpBody = try! JSONEncoder().encode(post)// set the appropriate HTTP header fieldsrequest.addValue("application/json", forHTTPHeaderField: "Content-Type")// HACK: this line allows the workspace or an Xcode playground to execute the request, but is not needed in a real applet runLoop = CFRunLoopGetCurrent()// task for making the requestlet task = URLSession.shared.dataTask(with: request) &#123;data, response, error in print(String(data: data!, encoding: .utf8)) // also not necessary in a real app CFRunLoopStop(runLoop)&#125;task.resume()// not necessaryCFRunLoopRun()s]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Binary Search Tree]]></title>
    <url>%2FLeetCode%2FBinary-Search-Tree.html</url>
    <content type="text"><![CDATA[BST ConstructionWrite a BST class for a Binary Search Tree. The class should support: Inserting values Removing values Searching for values/ Contain 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class BST: def __init__(self, value): self.value = value self.left = None self.right = None # Average: O(log(n)) time | O(1) space # Worst: O(n) time | O(1) space def insert(self, value): currentNode = self while True: if value &lt; currentNode.value: if currentNode.left is None: currentNode.left = BST(value) break else: currentNode = currentNode.left else: if currentNode.right is None: currentNode.right = BST(value) break else: currentNode = currentNode.right return self # Average: O(log(n)) time | O(1) space # Worst: O(n) time | O(1) space def contains(self, value): currentNode = self while currentNode is not None: if value &lt; currentNode.value: currentNode = currentNode.left elif value &gt; currentNode.value: currentNode = currentNode.right else: return True return False # Average: O(log(n)) time | O(1) space # Worst: O(n) time | O(1) space def remove(self, value, parrentNode=None): currentNode = self while currentNode is not None: if value &lt; currentNode.value: parrentNode = currentNode currentNode = currentNode.left elif value &gt; currentNode.value: parrentNode = currentNode currentNode = currentNode.right else: # Circumstance 1 if currentNode.left is not None and currentNode.right is not None: currentNode.value = currentNode.right.getMinValue() currentNode.right.remove(currentNode.value, currentNode) # Circumstance 2.2 elif parrentNode is None: if currentNode.left is not None: currentNode.value = currentNode.left.value currentNode.right = currentNode.left.right currentNode.left = currentNode.left.left elif currentNode.right is not None: currentNode.value = currentNode.right.value currentNode.left = currentNode.right.left currentNode.right = currentNode.right.right else: pass # Circumstance 2.1 elif currentNode == parrentNode.left: parrentNode.left = currentNode.left if currentNode.left is not None else currentNode.right # Circumstance 2.1 elif currentNode == parrentNode.right: parrentNode.right = currentNode.left if currentNode.left is not None else currentNode.right break return selfdef getMinValue(self): currentNode = self while currentNode.left is not None: currentNode = currentNode.left return currentNode.value There are three circumstances for remove have both left child and right child only have left child or right child or no child have parent node don’t have parent node Validate BST12345678910111213# O(n) time | O(d) spacedef validateBst(tree): return validateBstHelper(tree, float("-inf"), float("inf"))def validateBstHelper(tree, minValue, maxValue): if tree is None: return True if tree.value &lt; minValue or tree.value &gt;= maxValue: return False leftIsValid = validateBstHelper(tree.left, minValue, tree.value) rightIsValid = validateBstHelper(tree.right, tree.value, maxValue) return leftIsValid and rightIsValid BST Traversal1234567891011tree = 10 / \ 5 15 / \ \ 2 5 22 / 1 inOrderTraverse: [1, 2, 5, 5, 10, 15, 22] preOrderTraverse: [10, 5, 2, 1, 5, 15, 22] postOrderTraverse: [1, 2, 5, 5, 22, 15, 10] 12345678910111213141516171819202122232425# O(n) time | O(n) spacedef inOrderTraverse(tree, array): if tree is not None: inOrderTraverse(tree.left, array) array.append(tree.value) inOrderTraverse(tree.right, array) return array# O(n) time | O(n) spacedef preOrderTraverse(tree, array): if tree is not None: array.append(tree.value) preOrderTraverse(tree.left, array) preOrderTraverse(tree.right, array) return array# O(n) time | O(n) spacedef postOrderTraverse(tree, array): if tree is not None: postOrderTraverse(tree.left, array) postOrderTraverse(tree.right, array) array.append(tree.value) return array Min Height BSTWrite a function that takes in a sorted array of distince integers. Construct a BST from the integers, and return the root of the BST. Recursive! Use the insert function of Class BST Write the insert function by ourselves 12345678910111213141516171819# O(nlogn) time | O(n) space# insert O(logn) time * n elementsdef minHeightBst(array): return constructMinHeightBst(array, None, 0, len(array) - 1)def constructMinHeightBst(array, bst, startIdx, endIdx): if startIdx &gt; endIdx: return midIdx = (startIdx + endIdx) // 2 midValue = array[midIdx] if bst is None: bst = BST(midValue) else: bst.insert(midValue) constructMinHeightBst(array, bst, startIdx, midIdx - 1) constructMinHeightBst(array, bst, midIdx + 1, endIdx) return bst In order to optimize the program, the built-in insert function is not practical, and there is no need to start from the root node. Directly compare and insert. 123456789101112131415161718192021222324# O(n) time | O(n) spacedef minHeightBst(array): return constructMinHeightBst(array, None, 0, len(array) - 1)def constructMinHeightBst(array, bst, startIdx, endIdx): if startIdx &gt; endIdx: return midIdx = (startIdx + endIdx) // 2 newBstNode = BST(array[midIdx]) if bst is None: bst = newBstNode else: # Don't need to traverse elements from the root node. if bst.value &gt; array[midIdx]: bst.left = newBstNode bst = bst.left else: bst.right = newBstNode bst = bst.right constructMinHeightBst(array, bst, startIdx, midIdx - 1) constructMinHeightBst(array, bst, midIdx + 1, endIdx) return bst Make a few changes to the above code. 12345678def constructMinHeightBst(array, startIdx, endIdx): if startIdx &gt; endIdx: return None midIdx = (startIdx + endIdx) // 2 bst = BST(array[midIdx]) bst.left = constructMinHeightBst(array, startIdx, midIdx - 1) bst.right = constructMinHeightBst(array, midIdx + 1, endIdx) return bst Find Kth Largest Value in BST12345class BST: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right 12345678910111213# O(N) time, O(N) spacedef findKthLargestValueInBst(tree, k): array = [] array = reverseInorderTraverse(tree, array) return array[k - 1]def reverseInorderTraverse(tree, array): if tree is not None: reverseInorderTraverse(tree.right, array) array.append(tree.value) reverseInorderTraverse(tree.left, array) return array 12345678910111213141516171819202122class TreeInfo: def __init__(self, numberOfNodesVisited, latestVisitedNodeValue): self.numberOfNodesVisited = numberOfNodesVisited self.latestVisitedNodeValue = latestVisitedNodeValue# O(h + k) time, O(h) spacedef findKthLargestValueInBst(tree, k): treeInfo = TreeInfo(0, -1) reverseInorderTraverse(tree, k, treeInfo) return treeInfo.latestVisitedNodeValuedef reverseInorderTraverse(node, k, treeInfo): if node is None or treeInfo.numberOfNodesVisited &gt;= k: return reverseInorderTraverse(node.right, k, treeInfo) if treeInfo.numberOfNodesVisited &lt; k: treeInfo.latestVisitedNodeValue = node.value treeInfo.numberOfNodesVisited += 1 reverseInorderTraverse(node.left, k, treeInfo)]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift knowledge supplement]]></title>
    <url>%2FiOS%2FSwift-knowledge-supplement.html</url>
    <content type="text"><![CDATA[Associated ValueEnums can have raw values and associated values. A raw value is a string, character, or number (integer or floating-point) that can represent an enum case. 123456enum Position: Int &#123; case first = 1 case second = 2 case third = 3 case fourth = 4&#125; The example above defines a Position enum and uses type annotation to specify that all cases must have a raw integer value. 12// ": Int" is the type annotationenum Position: Int &#123; Then, for each case, a raw integer value is explicitly defined after the case name. 1234case first = 1case second = 2case third = 3case fourth = 4 Raw Value to EnumRaw values enable developers to convert values into enum cases, and vice versa. Let’s keep working with the Position enum. To convert an enum case into its raw value, use its rawValue property: 1234// convert a Position into a raw integer valuelet myPosition = Position.firstlet myPositionNumber = myPosition.rawValueprint(myPositionNumber) // prints "1" To convert a raw value to its respective enum case, use the initializer that takes a rawValue argument. 1234// convert an integer into a Positionlet rivalPositionNumber = 4let rivalPosition = Position(rawValue: rivalPositionNumber)print(rivalPosition == .fourth) // prints "true" Since there is no guarantee that a raw value has a corresponding case, any attempt to create an enum from a raw value will return an optional. To be safe, use if let to create enums from raw values. 12345678var randomNumber = 5// safely create enums from raw valuesif let newPosition = Position(rawValue: randomNumber) &#123; print("created \(newPosition) from raw value")&#125; else &#123; print("cannot create position from raw value")&#125; Implicit Raw ValuesIn certain situations, the Swift compiler can infer raw values for enum cases. If an enum uses raw string values, then each case is implicitly assigned a raw string value equal to the case’s name. 123456enum AudioRate: String &#123; case slow, normal, fast, custom&#125;print(AudioRate.slow.rawValue) // prints "slow"print(AudioRate.custom.rawValue) // prints "custom" If an enum uses raw integer values, then the compiler assigns zero to the first case, and increases the raw value for subsequent cases by one. 123456enum Endurance: Int &#123; case worst, abysmal, poor, medium, strong&#125;print(Endurance.poor.rawValue) // prints "2"print(Endurance.strong.rawValue) // prints "4" It is also possible to define an enum with implicitly and explicitly defined raw values; all implicitly defined raw integer values will be one greater than the previous raw integer value. If no previous raw integer value exists, then the compiler will assign zero to the enum case. 12345678enum SkewedEndurance: Int &#123; case worst, abysmal = 10, poor, medium, strong = 30&#125;print(SkewedEndurance.worst.rawValue) // prints "0"print(SkewedEndurance.poor.rawValue) // prints "11"print(SkewedEndurance.medium.rawValue) // prints "12"print(SkewedEndurance.strong.rawValue) // prints "30" You can mix and match implicit and explicit raw string values too: 12345678enum Axis: String &#123; case x case y case z = "zed"&#125;print(Axis.y.rawValue) // prints "y"print(Axis.z.rawValue) // prints "zed" Associated values12345678910111213141516171819202122232425262728293031//: Associated values are defined alongside enum cases. Associated values are not required; some enum cases may have an associated value while others do not. In the example below, `LibraryFee` has three cases with associated values and a case without an associated value.enum LibraryFee &#123; case overdueBook(Int) case lostBook(Double) case lostLibraryCard(Int) case annualDues&#125;let fee = LibraryFee.overdueBook(4)//: It can be very helpful to name associated values so that their intent is easily understood.enum DescriptiveLibraryFee &#123; case overdueBook(days: Int) case lostBook(price: Double) case lostLibraryCard(timesLost: Int) case annualDues&#125;let weekLateFee = DescriptiveLibraryFee.overdueBook(days: 7)//: Associated values are actually tuples. Therefore, an associated value can contain mutliple values.import UIKitenum ImageFilter &#123; case sepia case verticalGradient(from: UIColor, to: UIColor) case horizontalGradient(from: UIColor, to: UIColor) case sketch(penThickness: Double?)&#125;let fadeToBlack = ImageFilter.horizontalGradient(from: .gray, to: .black) 12345678910111213//: - Callout(Watch Out!)://: If all enum cases have an associated value of the same type, and it is static, then you might consider using a raw value instead.enum AudioRateAssociated &#123; case slow(value: Int) case normal(value: Int) case fast(value: Int) case custom(value: Int)&#125;// the associated values for `AudioRateAssociated` should be raw valuesenum AudioRateRaw: Int &#123; case slow, normal, fast, custom&#125; Extract the associated value with switch1234567891011import UIKitenum ImageFilter &#123; case sepia case verticalGradient(from: UIColor, to: UIColor) case horizontalGradient(from: UIColor, to: UIColor) case sketch(penThickness: Double?)&#125;let filter1 = ImageFilter.horizontalGradient(from: .gray, to: .black)let filter2 = ImageFilter.horizontalGradient(from: .white, to: .black) Switch12345678910111213141516171819202122232425262728293031323334353637383940414243//: Most often, associated values are extracted in a switch block. For cases that have an associated value, the `let` keyword followed by a name will extract each value from an associated value.switch filter1 &#123;case .sepia: print("sepia")case .verticalGradient(let color1, let color2): print("vertical gradient with \(color1) and \(color2)")case .horizontalGradient(let color1, let color2): print("horizontal gradient with \(color1) and \(color2)")case .sketch(let penThickness): if let thickness = penThickness &#123; print("sketch using \(thickness) thickness") &#125; else &#123; print("sketch using default thickness") &#125;&#125;//: Associated values can also be extracted as variables using the `var` keyword. Values extracted as variables are only available in the case where they are declared.switch filter1 &#123;case .horizontalGradient(var color1, let color2): color1 = .blue print("horizontal gradient with \(color1) and \(color2)")default: break&#125;//: To extract all values from an associated value as constants, use the `case let` syntax.switch filter1 &#123;case let .horizontalGradient(color1, color2): print("horizontal gradient with \(color1) and \(color2)")default: break&#125;//: To extract all values from an associated value as variables, use the `case var` syntax.switch filter1 &#123;case var .horizontalGradient(color1, color2): color1 = .red color2 = .blue print("horizontal gradient with \(color1) and \(color2)")default: break&#125; Watch out!12345678910111213141516171819202122232425262728293031323334353637383940414243444546//: - Callout(Watch Out!)://: Remember, switch statements must be exhaustive or Xcode will complain.// uncomment the switch statement below to see Xcode complain about a non-exhaustive switch statement./* switch filter1 &#123; case .horizontalGradient(var color1, let color2): color1 = .blue print("horizontal gradient with \(color1) and \(color2)") &#125; *///: If it is possible to treat two cases exactly the same, even when they have associated values, then you can combine cases. Note, the associated values must be the same type.switch filter1 &#123;case .verticalGradient(let color1, let color2), .horizontalGradient(let color1, let color2): print("a gradient from \(color1) to \(color2)")default: break&#125;//: - Callout(Watch Out!)://: If two cases are specified with a single case statement, then the tuple element names must match. switch filter1 &#123; // uncomment the case statement below to see Xcode complain that `color2` and `color3` must be used in every pattern (i.e. the tuple element names don't match) /* case .verticalGradient(let color1, let color3), .horizontalGradient(let color1, let color2): print("a gradient from \(color1) to \(color2)") */ default: break &#125;//: If associated values are not needed for computation, then they can be ignored. The example below ignores the associated value for the horizontal gradient.switch filter1 &#123;case .horizontalGradient: print("the filter is a horizontal gradient!")default: break&#125;//: It is also possible to partially ignore values in an associated value, while extracting others.switch filter1 &#123;case .horizontalGradient(let color1, _): print("the horizontal gradient's first color is \(color1)")default: break&#125; “where” keyword123456789//: Associated values may also be extracted based on conditions specified using the `where` keyword. If all conditions are held, then the values are extracted and the case statement is executed.switch filter1 &#123;case .horizontalGradient(let color1, _) where color1 == .white: print("the horizontal gradient's first color is white")case .horizontalGradient(_, let color2) where color2 == .black: print("the horizontal gradient's second color is black")default: break&#125; Computed properties12345678910111213141516171819202122232425262728293031//: Associated values can be extracted using computed properties. By using a computed property, you may avoid duplicate switch statements.extension ImageFilter &#123; var colors: (from: UIColor, to: UIColor)? &#123; switch self &#123; case .verticalGradient(let from, let to), .horizontalGradient(let from, let to): return (from, to) default: return nil &#125; &#125; var penThickness: Double? &#123; switch self &#123; case .sketch(let penThickness): return penThickness default: return nil &#125; &#125;&#125;let filter3 = ImageFilter.sketch(penThickness: 4.0)filter1.colorsfilter1.colors?.fromfilter1.colors?.tofilter3.colors // nil filter1.penThickness // nilfilter3.penThickness // 4 Extract with if1234567891011import UIKitenum ImageFilter &#123; case sepia case verticalGradient(from: UIColor, to: UIColor) case horizontalGradient(from: UIColor, to: UIColor) case sketch(penThickness: Double?)&#125;let filter1 = ImageFilter.horizontalGradient(from: .gray, to: .black)let filter2 = ImageFilter.horizontalGradient(from: .white, to: .black) 12345678910111213141516171819202122232425262728//: `if case` works alongside the equals operator (=) to check and extract an associated value from an enum. While the syntax may look strange, the equals operator still behaves in an intuitive way; that is, the associated value on the left-hand side (containing `color1` and `color2`) is set equal to the associated value for the enum on the right-hand side (`filter1`).if case ImageFilter.horizontalGradient(let color1, var color2) = filter1 &#123; color2 = .red print("horizontal gradient with \(color1) and \(color2)")&#125;//: To extract all values as constants use `if case let`.if case let ImageFilter.horizontalGradient(color1, color2) = filter1 &#123; print("horizontal gradient with \(color1) and \(color2)")&#125;//: Complex conditionals can be formed using `if case` and conditional statements separated by commas. If the conditional statements are held true, then the values are extracted and usable from within the `if case` block.if case let ImageFilter.horizontalGradient(_, color2) = filter1, color2 == .black &#123; print("the horizontal gradient's second color is \(color2)")&#125;//: A single associated value can also be extracted as a computed property. By using a computed property, you may avoid duplicate `if case` statements.extension ImageFilter &#123; var hasHeavyPenThickness: Bool &#123; if case let ImageFilter.sketch(penThickness) = self, let thickness = penThickness, thickness &gt; 5.0 &#123; return true &#125; else &#123; return false &#125; &#125;&#125;filter1.hasHeavyPenThickness Enums with Enums123456789101112131415enum ShirtSize &#123; case extraSmall case small case medium case large case extraLarge&#125;enum Search &#123; case forShirts(sizes: [ShirtSize]) case forName(name: String)&#125;let searchForBigShirts = Search.forShirts(sizes: [.large, .extraLarge])let searchForHenleys = Search.forName(name: "henley") GuardGuard statement123456789101112131415161718192021222324func takeOff(passengersSeated: Bool, crewReady: Bool, runwayClear: Bool) &#123; guard passengersSeated else &#123; return &#125; guard crewReady else &#123; return &#125; guard runwayClear else &#123; return &#125; print("✈️ Lifts off runway")&#125;// the runway isn't clear, the airplane cannot take offtakeOff(passengersSeated: true, crewReady: true, runwayClear: false)// The samefunc takeOffCombineGuards(passengersSeated: Bool, crewReady: Bool, runwayClear: Bool) &#123; guard passengersSeated, crewReady, runwayClear else &#123; return &#125; print("✈️ Lifts off runway")&#125;// Add sthfunc takeOffGuardWithCode(passengersSeated: Bool, crewReady: Bool, runwayClear: Bool) &#123; guard passengersSeated, crewReady, runwayClear else &#123; print("tell passengers there will be a delay") return &#125; print("✈️ Lifts off runway")&#125; Guard versus IfThe guard and if keywords can serve similar purposes in Swift, but they should not be used interchangeably. Instead, use the following guidelines to decide when to use guard versus if: guard should be used to check for preconditions and early exit if should be used to change execution path based on some condition(s) Guard: whether the credit card is validate and whether the order is scheduled If: wether the user enter a discount code Guard with Optionals123456789101112func takeOffGuardVar(passengersSeated: Bool, crewReady: Bool, runwayClear: Bool, crewLeader: String?) &#123; guard passengersSeated, crewReady, runwayClear else &#123; return &#125; guard var crewLeaderVariable = crewLeader else &#123; return &#125; // modify the crew leader crewLeaderVariable = crewLeaderVariable.uppercased() print("\(crewLeaderVariable): \"Takeoff checks complete!\"") print("✈️ Lifts off runway")&#125;takeOffGuardVar(passengersSeated: true, crewReady: true, runwayClear: true, crewLeader: "👩🏻‍✈️ Natalie") Example 11234567891011121314struct Student &#123; var name: String var grades: [Double] var average: Double &#123; return grades.reduce(0) &#123; return $0 + $1 &#125; / Double(grades.count) &#125;&#125;func passStudent(_ student: Student?) &#123; guard let student = student, student.average &gt;= 75 else &#123; return &#125; print("\(student.name) passed!")&#125;passStudent(Student(name: "Sam", grades: [70, 90, 84, 62, 88])) The reduce funtion12345let numbers = [1, 2, 3, 4]let numberSum = numbers.reduce(0, &#123; x, y inx + y&#125;)// numberSum == 10 One website.. Another website. Swift in keyword.1&#123; /parameters and type/ in /function body/ &#125; $0 and $1$0 is the first parameter passed into the closure. $1 is the second parameter, etc. 123456789add = &#123; arg1, arg2 inarg1 + arg2&#125;add = &#123;$0 + $1&#125;let result = add(20, 20) // 40 Example 2123456789101112131415struct Student &#123; var name: String var grades: [Double] var topPassingGrade: Double? &#123; let passingGrades = grades.filter &#123; return $0 &gt;= 75 &#125; return passingGrades.max() // It can be "nil". &#125;&#125;func notifyUser(_ student: Student) &#123; guard let _ = student.topPassingGrade else &#123; return &#125; print("you've passed!")&#125;notifyUser(Student(name: "Ulysses", grades: [70, 60, 74, 76, 63])) The filter function 12345&gt; let cast = ["Vivien", "Marlon", "Kim", "Karl"]&gt; let shortNames = cast.filter &#123; $0.count &lt; 5 &#125;&gt; print(shortNames)&gt; // Prints "["Kim", "Karl"]"&gt; Guard let Versus If let When optional values are used with guard let (or guard var) they are bound as non-optional values and available in the rest of the scope where the guard statement appears. This differs from how optionals work with if let. With if let, optionals are bound as non-optional constants, and they are only available in the body of the if let statement. After the ‘guard let’ judgement, the optional is transformed to a variable or constant. ErrorsThe errors referred to by “error handling” are not like warnings or issues raised by Xcode and the compiler. They are also not software bugs. Instead, these errors are either intentionally caused or generated in situations where correct behavior cannot be fully guaranteed. a compile-time error (or warning) can be generated by the compiler, before code is run a run-time error (sometimes called a logic error) is caused by code that is syntactically correct, but logically incorrect or causes a crash when code is running These kinds of errors can be fixed. The errors in “error handling” can happen even when code is syntactically correct. 123456789101112131415161718192021// When a catch block is executed, it automatically defines a constant called "error". // This constant is of type `Error` and it has a localized description property with helpful information about the cause of the problem.if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") &#123; do &#123; let content = try String(contentsOf: fileURL, encoding: .utf8) print(content) &#125; catch &#123; print(error) // notice, error is implicitly defined print(error.localizedDescription) &#125;&#125;//: For readability, the "error" constant can be explicitly defined using `catch let error`.if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") &#123; do &#123; let content = try String(contentsOf: fileURL, encoding: .utf8) print(content) &#125; catch let error &#123; print(error) // error is defined and available for use in the catch block &#125;&#125; Types of errorWe can use do catch to handle different type of the error. 123456789101112131415if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") &#123; // create a url that does not exist let erroneousURL = fileURL.appendingPathComponent("unknown-path") do &#123; let content = try String(contentsOf: erroneousURL, encoding: .utf8) print(content) &#125; catch CocoaError.fileReadInapplicableStringEncoding &#123; print("cannot read file into a string") &#125; catch CocoaError.fileReadUnknown &#123; print("file unknown, cannot read") &#125; catch &#123; print("\(error)") &#125;&#125; How can we get the error type? Use the website to search the error code. Catch isAlternatively, errors can be caught by type using the catch is syntax. As seen before, all errors implement the Error protocol. Additionally, all errors extend from NSError which provides more information for troubleshooting like a string property called “domain” that classifies the origin of an error. An error’s domain may also suggest if the error can be casted into a more specific type like CocoaError, POSIXError, or MachError. See Apple’s documentation on error objects, domains, and codes to learn more. 12345678910111213if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") &#123; // create a url that does not exist let erroneousURL = fileURL.appendingPathComponent("unknown-path") do &#123; let content = try String(contentsOf: erroneousURL, encoding: .utf8) print(content) &#125; catch is CocoaError &#123; print("this error is a CocoaError") &#125; catch &#123; print("\(error)") &#125;&#125; Catch let … as …To catch and cast an error by type, combine catch let error with a type cast. In the example below, an error is casted into CocoaError which exposes common error codes generated by core Apple frameworks. 1234567891011121314151617181920if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") &#123; // create a url that does not exist let erroneousURL = fileURL.appendingPathComponent("unknown-path") do &#123; let content = try String(contentsOf: erroneousURL, encoding: .utf8) print(content) &#125; catch let error as CocoaError &#123; /* handle if error can be casted into a `CocoaError` */ switch error.errorCode &#123; case CocoaError.fileReadInapplicableStringEncoding.rawValue: print("cannot read file into a string") case CocoaError.fileReadUnknown.rawValue: print("file unknown, cannot read") default: print("cocoa error with code: \(error.errorCode)") &#125; &#125; catch &#123; print("\(error)") &#125;&#125; Propogate errorTo propagate all possible errors to the calling site, start by removing the do-catch statement and adding throws to the signature of the function which calls the error-prone code. 1234567891011121314// add "trows" to the functionfunc readFileIntoStringWithThrows(fileName: String, fileExtension: String) throws &#123; if let fileURL = Bundle.main.url(forResource: fileName, withExtension: fileExtension) &#123; let content = try String(contentsOf: fileURL, encoding: .utf8) print(content) &#125;&#125;// Now, any code that calls `readFileIntoStringWithThrows` is responsible for handling any errors it generates.do &#123; try readFileIntoStringWithThrows(fileName: "swift", fileExtension: "png")&#125; catch &#123; print("the error was propagated to me, and I handled it!")&#125; Sometimes it is appropriate to handle some errors immediately while propagating others for further processing. To propagate a specific error, use the throw keyword. 123456789101112131415161718func readFileIntoStringHandleAndThrow(fileName: String, fileExtension: String) throws &#123; if let fileURL = Bundle.main.url(forResource: fileName, withExtension: fileExtension) &#123; do &#123; let content = try String(contentsOf: fileURL, encoding: .utf8) print(content) &#125; catch CocoaError.fileReadUnknown &#123; print("file unknown, cannot read") &#125; catch let error &#123; throw error /* throw (propagate) this error to the call site */ &#125; &#125;&#125;do &#123; try readFileIntoStringHandleAndThrow(fileName: "swift", fileExtension: "png")&#125; catch let error &#123; print("handling error: \(error.localizedDescription)")&#125; try? and try!Try comes in two other forms: try? and try!. try? executes error-prone code, and if any error is generated, then it is converted into an optional where the underlying value has the same type as the error-prone function or intializer’s return type. This can simplify code, but the ability to analyze errors is lost. 12345678910111213func printFileContentsTry() &#123; if let fileURL = Bundle.main.url(forResource: "swift", withExtension: "png") &#123; let content = try? String(contentsOf: fileURL, encoding: .utf8) print(content ?? "content is nil") // preferably, combine `if let` with `try?`; it's easier to read if let content = try? String(contentsOf: fileURL, encoding: .utf8) &#123; print(content) &#125; else &#123; print("could not read contents of file into string") &#125; &#125;&#125; try! executes error-prone code while foregoing any opportunity to safely handle an error. If an error-prone function is called using try! and it fails, then the entire app or playground crashes. 12345// try! should only be used if there is no risk of error; generally, this is not advisedif let fileURL = Bundle.main.url(forResource: "swift", withExtension: "txt") &#123; let content = try! String(contentsOf: fileURL, encoding: .utf8) print(content)&#125; Error handle summaryThere are four ways to handle the error. Handle Error with Do-Catch Convert Error to Optional with try? Ignore Error with try! Propagate Error Create custom errorTo create a custom error, define a type that inherits from the Error protocol. Often, enums are used for this purpose. 12345678910111213141516enum SimplePurchaseError: Error &#123; case invalidAddress case cardRejected case cartWeightLimitExceeded case insufficientStock&#125;func makeBadPurchase() throws &#123; throw SimplePurchaseError.cardRejected // throw a custom error&#125;do &#123; try makeBadPurchase()&#125; catch &#123; print(error) // Result: cardRejected&#125; When using an enum to define a custom error, use associated values to add helpful debugging information. 123456789101112131415161718192021222324252627282930enum ComplexPurchaseError: Error &#123; case invalidAddress case cardRejected case cartWeightLimitExceeded(Double) case insufficientStock(String)&#125;func attemptPurchase(withWeight weight: Double) throws &#123; if weight &gt; 100 &#123; // throw a custom error with an associated value throw ComplexPurchaseError.cartWeightLimitExceeded(-1 * (100 - weight)) &#125; else &#123; print("purchase succeeded!") &#125;&#125;do &#123; try attemptPurchase(withWeight: 125.6)&#125; catch let error as ComplexPurchaseError &#123; switch error &#123; case let .cartWeightLimitExceeded(weight): /* extract the associated value */ print("purchase failed. weight exceeds limit by: \(weight)") // Result: purchase failed. weight exceeds limit by: 25.599 default: print(error) break &#125;&#125; catch &#123; print(error)&#125; Describe custom errorYou can add extra debugging information to a custom error by also implementing the LocalizedError and CustomNSError protocols. LocalizedErrorLocalizedError includes properties which should be used to provide localized information about an error. 12345678910111213141516/// Describes an error that provides localized messages describing why/// an error occurred and provides more information about the error.public protocol LocalizedError : Error &#123; /// A localized message describing what error occurred. public var errorDescription: String? &#123; get &#125; /// A localized message describing the reason for the failure. public var failureReason: String? &#123; get &#125; /// A localized message describing how one might recover from the failure. public var recoverySuggestion: String? &#123; get &#125; /// A localized message providing "help" text if the user requests help. public var helpAnchor: String? &#123; get &#125;&#125; The following example describes the failureReason for a PurchaseError. For brevity, the other properties have been excluded. 12345678910111213141516171819202122232425extension PurchaseError: LocalizedError &#123; var failureReason: String? &#123; switch self &#123; case .invalidAddress: return NSLocalizedString("address contained invalid or empty fields", comment: "") case .cardRejected: return NSLocalizedString("card number or csv code is invalid", comment: "") case let .cartWeightLimitExceeded(amount): return NSLocalizedString("weight limit was by exceeded \(amount)", comment: "") case .insufficientStock: return NSLocalizedString("insufficient stock", comment: "") &#125; &#125;&#125;do &#123; try makeBadPurchase() // a fictitious function that might throw an error&#125; catch let error as LocalizedError &#123; // cast error to `LocalizedError` if let description = error.errorDescription &#123; print(description) &#125; if let failureReason = error.failureReason &#123; print(failureReason) &#125; if let recoverySuggestion = error.recoverySuggestion &#123; print(recoverySuggestion) &#125; if let helpAnchor = error.helpAnchor &#123; print(helpAnchor) &#125;&#125; catch &#123; print(error)&#125; Note: Comment is left blank for each NSLocalizedString. Again, this is for brevity. In practice, you should use comments that provide sufficient context about a localized string so that translators can produce more accurate translations. Failure to do so may result in vastly different translations. CustomNSErrorRecall, all errors extend from NSError. By default, the properties of NSError, like domain, have inferred values. To provide more accurate values for NSError properties, implement CustomNSError. 12345678910111213/// Describes an error type that specifically provides a domain, code,/// and user-info dictionary.public protocol CustomNSError : Error &#123; /// The domain of the error. public static var errorDomain: String &#123; get &#125; /// The error code within the given domain. public var errorCode: Int &#123; get &#125; /// The user-info dictionary. public var errorUserInfo: [String : Any] &#123; get &#125;&#125; If an error implements CustomNSError, then when casted to an NSError, it will contain the values provided by the protocol implementation. 123456789101112131415161718192021222324252627282930extension PurchaseError: CustomNSError &#123; // domain and error code... /// The user-info dictionary. var errorUserInfo: [String: Any] &#123; switch self &#123; case let .cartWeightLimitExceeded(amount): return [ "weightLimit": 100.0, "weightExceeded": amount ] case let .insufficientStock(items): return [ "itemsOutOfStock": items ] default: return [:] &#125; &#125;&#125;do &#123; try attemptPurchase(withWeight: 125.6) // a fictitious function that might throw an error&#125; catch let error as NSError &#123; // cast error to `NSError` print(error.domain) print(error.code) print(error.userInfo) // prints "["weightExceeded": 25.599999999999994, "weightLimit": 100.0]"&#125; catch &#123; print(error)&#125; deferThe last topic related to errors is the defer keyword. While uncommon, you may find it coupled with error handling because it can be used to execute a block of code before an error-generating scope is exited. Typically, a defer block is provided near the top of a function. It cannot contain any code that changes the flow of control, like a break or return statement, or throwing an error. Also, multiple defer blocks may be defined, but they are executed in reverse order of when they appear. 1234567891011121314151617func attemptPurchaseWithMultipleDefers() &#123; // before this function exits, execute this defer block defer &#123; print("then, close the secure purchase session") &#125; defer &#123; print("first, clear order") &#125; do &#123; try processOrder() &#125; catch &#123; print("\(error)") &#125;&#125;attemptPurchaseWithMultipleDefers()// before `attemptPurchaseWithMultipleDefers` exits, it prints…// "first, clear order"// "then, close the secure purchase session" GenericsArray are GenericUpon first glance, many do not realize that Swift arrays use generics. Specifically, the type that a Swift array stores is generic — it can be anything. When declaring an array using its more longhand syntax, this becomes apparent. 12var intArray = Array&lt;Int&gt;()var stringArray: Array&lt;String&gt; = ["one", "two", "three"] The type specified in the brackets (ex. ““) is called a “concrete type”. When specified, the concrete type takes the place of a generic type. Because Swift arrays use generics, they behave the same, regardless of the concrete type. Generic FunctionGenerics can be applied to functions and types. To write a generic function, specify a generic type after the function name using the bracket notation (ex. func myFunction&lt;Type&gt;). Then, for any arguments that should be generic, use the generic type instead of a concrete type. Below, the generic type is called Type; Type can represent any type. 123456func printTypeWithNamedGenericType&lt;Type&gt;(_ argument: Type) &#123; print(type(of: argument))&#125;printTypeWithNamedGenericType(4) // Int printTypeWithNamedGenericType("udacity") // String Now, the type is for any type. We can’t implement some functions for this value. For example, we can’t use “Plus” function, so we should specify a type for it. A generic type can be bound or constrained such that it can only represent concrete types which adhere to some protocol or inherit from a certain class. In the example below, the generic type is constrained such that it can only represent types which implement the UnsignedInteger protocol — essentially, non-negative integers. 123456789101112131415func printUIntTypes&lt;Type: UnsignedInteger&gt;(_ argument: Type) &#123; print(type(of: argument))&#125;let unsignedInt: UInt = 4let unsignedInt8: UInt8 = 4let unsignedInt16: UInt16 = 4printUIntTypes(unsignedInt)printUIntTypes(unsignedInt8)printUIntTypes(unsignedInt16)// When a generic type is constrained, any concrete types that do not adhere to the constraint will cause Xcode to complain.//printUIntTypes(4) /* `Int` is not unsigned because it can store negative values *///printUIntTypes(-4)//printUIntTypes("abc") Multiple generic functionGeneric functions and types can specify multiple generic types, simply use a comma to separate them. 123456func combineUInt&lt;Type1: UnsignedInteger, Type2&gt;(_ int: Type1, withString string: Type2) -&gt; String &#123; return "\(int) \(string)"&#125;let unsignedInt: UInt = 4print(combineUInt(unsignedInt, withString: "zebras")) Generic TypeGenerics can be applied to an object’s properties to create what is known as a generic type. Similar to generic functions, a generic type is created by specifying the object’s name followed by a generic type using the bracket notation (ex. struct MyType&lt;Type&gt;). Then, for any properties that should be generic, use the generic type instead of a concrete type. 12345678910111213141516171819202122232425262728struct TypeAnalyzer&lt;T&gt; &#123; let value: T // represents the sub-structure of the generic type var mirror: Mirror &#123; return Mirror(reflecting: value) &#125; // print information about the type func analyze() &#123; print("Type: \(type(of: value))") print("Value: \(value)") if let superClassMirror = mirror.superclassMirror &#123; print("Superclass: \(superClassMirror.subjectType)") &#125; &#125;&#125;let x = TypeAnalyzer(value: 2)x.analyze()// Type: Int// Value: 2let view = TypeAnalyzer&lt;UIView&gt;(value: UIView(frame: CGRect.zero))view.analyze()// Type: UIView// Value: &lt;UIView: 0x7f82c0a0dfc0; frame = (0 0; 0 0); layer = &lt;CALayer: 0x6000035e6140&gt;&gt;// Superclass: UIResponder Like generic functions, the generic type can be named and constained. In the example below, ZooExhibit is defined where its animals property is generic and constrained to any type that implements the Animal protocol. 1234567891011121314151617181920212223242526272829303132333435363738394041protocol Animal &#123; var name: String &#123; get &#125; static var commonName: String &#123; get &#125; static var emoji: String &#123; get &#125;&#125;struct Whale: Animal &#123; let name: String static let commonName = "Whale" static let emoji = "🐳"&#125;struct Dolphin: Animal &#123; let name: String static let commonName = "Dolphin" static let emoji = "🐬"&#125;struct ZooExhibit&lt;AnimalType: Animal&gt; &#123; let animals: [AnimalType] func tourTheExhibit() &#123; print("Welcome to the \(AnimalType.commonName) Exhibit \(AnimalType.emoji)!") for animal in animals &#123; print("Say hello to \(animal.name) \(AnimalType.emoji).") &#125; &#125;&#125;let exhibit1 = ZooExhibit(animals: [Whale(name: "Wendy"), Whale(name: "Wu")])exhibit1.tourTheExhibit()// Welcome to the Whale Exhibit 🐳!// Say hello to Wendy 🐳.// Say hello to Wu 🐳.// the longhand syntax can be used to specify the concrete typelet exhibit2 = ZooExhibit&lt;Dolphin&gt;(animals: [Dolphin(name: "Dilbert"), Dolphin(name: "Dezeri")])exhibit2.tourTheExhibit()// Welcome to the Dolphin Exhibit 🐬!// Say hello to Dilbert 🐬.// Say hello to Dezeri 🐬. A single generic type can only be substituted with one concrete type. If Xcode is unable to determine the concrete type that should be substituted for a generic type, it will complain. 1// let exhibit3 = ZooExhibit(animals: [Whale(name: "Wilber"), Dolphin(name: "Daphnie")]) Extensions can be combined with generics for truly powerful effects. With an extension, it is possible to specify functionality that should only apply to a generic type when the concrete type meets inherits from a specific protocol. 1234567891011121314151617181920protocol Feedable &#123; static var favoriteFood: String &#123; get &#125;&#125;extension Dolphin: Feedable &#123; static let favoriteFood = "🐟"&#125;extension ZooExhibit where AnimalType: Feedable &#123; func feedTheAnimals() &#123; for animal in animals &#123; print("You feed \(animal.name) \(AnimalType.emoji) some \(AnimalType.favoriteFood).") &#125; &#125;&#125;exhibit2.feedTheAnimals()// because `Whale` is not `Feedable`, the `feedTheAnimals()` function doesn't exist for the whale exhibit//exhibit1.feedTheAnimals() Subclass a Generic TypeA generic type can be subclassed, assuming it is a class and not a struct. To demonstrate an example of subclassing a generic type, the Animal, Whale, and ZooExhibit types are defined: 123456789101112131415161718192021222324protocol Animal &#123; var name: String &#123; get &#125; static var commonName: String &#123; get &#125;&#125;struct Whale: Animal &#123; let name: String static let commonName = "Whale"&#125;class ZooExhibit&lt;AnimalType: Animal&gt; &#123; let animals: [AnimalType] init(animals: [AnimalType]) &#123; self.animals = animals &#125; func tourTheExhibit() &#123; print("Welcome to the \(AnimalType.commonName) Exhibit!") for animal in animals &#123; print("Say hello to \(animal.name).") &#125; &#125;&#125; To subclass the generic type ZooExhibit, one must define a new class with a generic type that can be substituted for AnimalType (any type that implements the Animal protocol). In the subclass below, the generic type A is constrained such that it must implement the Animal protocol. Hence, when ZooExhibit is specified as the superclass, the type A can be used without error. 123456789101112131415class TravelingExhibit&lt;A: Animal&gt;: ZooExhibit&lt;A&gt; &#123; var location: String init(location: String, animals: [A]) &#123; self.location = location super.init(animals: animals) &#125; override func tourTheExhibit() &#123; print("Welcome to the \(A.commonName) Exhibit at \(location)!") for animal in animals &#123; print("Say hello to \(animal.name).") &#125; &#125;&#125; But, if a subclass tries to specify a generic type that does not satisfy the constraints from the parent class, then Xcode will generate an error. 123456789// this generates an error because `B` does not conform to `Animal` protocolclass TankExhibit&lt;B&gt;: ZooExhibit&lt;B&gt; &#123; let volume: Double init(volume: Double, animals: [B]) &#123; self.volume = volume super.init(animals: animals) &#125;&#125; Once a generic type is subclassed, it can be created and used in a manner similar to the base class. 1234567// exhibit is of type `TravelingExhibit&lt;Whale&gt;`let exhibit = TravelingExhibit(location: "Oakland Zoo", animals: [Whale(name: "Watson"), Whale(name: "Wren")])exhibit.tourTheExhibit()// change exhibit locationexhibit.location = "San Francisco Zoo"exhibit.tourTheExhibit() ClosureCreate a closure123456789let closures = [f, &#123; (x:Int) -&gt; Int in return x * 2 &#125;, &#123; x in return x - 8 &#125;, &#123; x in x * x &#125;, &#123; $0 * 42 &#125;]for fn in closures &#123; fn(42) // 5 results&#125; Closure and Function1234567891011let f = &#123;(x: Int) -&gt; Int in return x + 42&#125;f(9) // 51f("99") // error// this function is the same as the closurefunc foo(x: Int) -&gt; Int &#123; return x + 42&#125; alias1234567typealias Integer = Intlet z: Integer = 42let zz: Int = 42// (Int) -&gt; Inttypealias IntToInt = (Int) -&gt; Int 1234567891011121314151617181920212223typealias IntMaker = (Void) -&gt; Int// the function returns another function/closurefunc makeCounter() -&gt; IntMaker &#123; var n = 0 func adder() -&gt; Int &#123; n = n + 1 return n &#125; return adder&#125;let counter1 = makeCounter() // counter 1 is equal to the adder functionlet counter2 = makeCounter()counter1() // 1counter1() // 2counter1() // 3// the "n" is not the same for difference instancecounter2() // 1]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UITableView and Navigation]]></title>
    <url>%2FiOS%2FUITableView.html</url>
    <content type="text"><![CDATA[Create UITabelView We need to link two delegates(datasource &amp; delegate) from the tabelview in the storyboard to the ViewController. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import UIKitclass ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate &#123; // MARK: Properties // Get ahold of some villains, for the table // This is an array of Villain instances let allVillains = Villain.allVillains // MARK: Table View Data Source // The number of rows func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return self.allVillains.count &#125; // The text of every row func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: "VillainCell")! let villain = self.allVillains[(indexPath as NSIndexPath).row] // Set the name and image cell.textLabel?.text = villain.name cell.imageView?.image = UIImage(named: villain.imageName) // If the cell has a detail label, we will put the evil scheme in. if let detailTextLabel = cell.detailTextLabel &#123; detailTextLabel.text = "Scheme: \(villain.evilScheme)" &#125; return cell &#125; func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool &#123; return true &#125; // Use navigationController to show the corresponding page of each row func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; let detailController = storyboard?.instantiateViewController(withIdentifier: "VillainDetailViewController") as! VillainDetailViewController detailController.villain = self.allVillains[indexPath.row] navigationController?.pushViewController(detailController, animated: true) &#125;&#125; Creating and preparing the DetailViewController Create a VillainDetailViewController with a 100x80 image view, and a label Give the VillainDetailViewController a Storyboard ID Give the VillainDetailViewController a villain property Write the viewWillAppear method in the VillainDetailViewController so that it sets the image and label Create the Villain struct1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162struct Villain &#123; // MARK: Properties let name: String let evilScheme: String let imageName: String static let NameKey = "NameKey" static let EvilSchemeKey = "EvilScheme" static let ImageNameKey = "ImageNameKey" // MARK: Initializer // Generate a Villain from a three entry dictionary init(dictionary: [String : String]) &#123; self.name = dictionary[Villain.NameKey]! self.evilScheme = dictionary[Villain.EvilSchemeKey]! self.imageName = dictionary[Villain.ImageNameKey]! &#125;&#125;// MARK: - Villain (All Villians)/*** This extension adds static variable allVillains. An array of Villain objects*/extension Villain &#123; // Generate an array full of all of the villains in static var allVillains: [Villain] &#123; var villainArray = [Villain]() for d in Villain.localVillainData() &#123; villainArray.append(Villain(dictionary: d)) &#125; return villainArray &#125; static func localVillainData() -&gt; [[String : String]] &#123; return [ [Villain.NameKey : "Mr. Big", Villain.EvilSchemeKey : "Smuggle herion.", Villain.ImageNameKey : "Big"], [Villain.NameKey : "Ernest Blofeld", Villain.EvilSchemeKey : "Many, many, schemes.", Villain.ImageNameKey : "Blofeld"], [Villain.NameKey : "Sir Hugo Drax", Villain.EvilSchemeKey : "Nerve gass Earth, from the Moon.", Villain.ImageNameKey : "Drax"], [Villain.NameKey : "Jaws", Villain.EvilSchemeKey : "Kill Bond with huge metal teeth.", Villain.ImageNameKey : "Jaws"], [Villain.NameKey : "Rosa Klebb", Villain.EvilSchemeKey : "Humiliate MI6", Villain.ImageNameKey : "Klebb"], [Villain.NameKey : "Emilio Largo", Villain.EvilSchemeKey : "Steal nuclear weapons", Villain.ImageNameKey : "EmilioLargo"], [Villain.NameKey : "Le Chiffre", Villain.EvilSchemeKey : "Beat bond at poker.", Villain.ImageNameKey : "Lechiffre"], [Villain.NameKey : "Odd Job", Villain.EvilSchemeKey : "Kill Bond with razor hat.", Villain.ImageNameKey : "OddJob"], [Villain.NameKey : "Francisco Scaramanga", Villain.EvilSchemeKey : "Kill Bond after assembling a golden gun.", Villain.ImageNameKey : "Scaramanga"], [Villain.NameKey : "Raoul Silva", Villain.EvilSchemeKey : "Kill M.", Villain.ImageNameKey : "Silva"], [Villain.NameKey : "Alec Trevelyan", Villain.EvilSchemeKey : "Nuke London, after killing Bond.", Villain.ImageNameKey : "Trevelyan"], [Villain.NameKey : "Auric Goldfinger", Villain.EvilSchemeKey : "Nuke Fort Knox.", Villain.ImageNameKey : "Goldfinger"], [Villain.NameKey : "Max Zorin", Villain.EvilSchemeKey : "Destroy Silicon Valley with an earthquake and flood.", Villain.ImageNameKey : "Zorin"] ] &#125;&#125; How to create a Navigation ViewControllerStep 1: Create a new single view application Step 2: Delete the single view controller (You can delete this view controller by selecting the yellow icon and then tapping the delete button) Step 3: Drag a UINavigationController into the storyboard from the object library. Step 4: Delete the automatically generated root view controller and drag in a new view controller. To reset the Navigation Controller’s Root View Controller property control click on the Navigation Controller’s round yellow icon and drag a line from the root view controller triggered segue to your new view controller. Implement the StartOver button123456789101112131415161718class MYOAViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() navigationItem.rightBarButtonItem = UIBarButtonItem( title: "Start Over", style: .plain, target: self, action: #selector(startOver)) &#125; func startOver() &#123; if let navigationController = navigationController &#123; navigationController.popToRootViewController(animated: true) &#125; &#125;&#125; The Navigation Controller is a stack data structure. How to Update the Rock Paper Scissors App with NavigationStep 1. Drag a navigation controller into the storyboard and set its root view controller property to the RockPaperScissorsViewController. Step 2. Change each of the three segues one at a time. Scissors is easiest: Just change the type to “show” instead of “modal”. Note the invocation of prepare(for:sender:). Paper is essentially the same, but follow the invocation in the view controller and note the invocations of an IBAction, and the performSegue(withIdentifier:sender:) method. Rock is always the hard way. Read the documentation for UINavigationController to see how to programmatically push the results controller onto the navigation controller. Remember that the RockPaperScissorsViewController will have a navigation controller property that you can use in the action. Step 3. Edit the playAgainButtonPressed method so that the “Play Again” button behaves similarly to the “Start Over” button in Make Your Own Adventure.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MVC Pattern]]></title>
    <url>%2FiOS%2FMVC-Pattern.html</url>
    <content type="text"><![CDATA[Model ObjectsModel objects encapsulate the data specific to an application and define the logic and computation that manipulate and process that data. For example, a model object might represent a character in a game or a contact in an address book. A model object can have to-one and to-many relationships with other model objects, and so sometimes the model layer of an application effectively is one or more object graphs. Much of the data that is part of the persistent state of the application (whether that persistent state is stored in files or databases) should reside in the model objects after the data is loaded into the application. Because model objects represent knowledge and expertise related to a specific problem domain, they can be reused in similar problem domains. Ideally, a model object should have no explicit connection to the view objects that present its data and allow users to edit that data—it should not be concerned with user-interface and presentation issues. Communication: User actions in the view layer that create or modify data are communicated through a controller object and result in the creation or updating of a model object. When a model object changes (for example, new data is received over a network connection), it notifies a controller object, which updates the appropriate view objects. View ObjectsA view object is an object in an application that users can see. A view object knows how to draw itself and can respond to user actions. A major purpose of view objects is to display data from the application’s model objects and to enable the editing of that data. Despite this, view objects are typically decoupled from model objects in an MVC application. Because you typically reuse and reconfigure them, view objects provide consistency between applications. Both the UIKit and AppKit frameworks provide collections of view classes, and Interface Builder offers dozens of view objects in its Library. Communication: View objects learn about changes in model data through the application’s controller objects and communicate user-initiated changes—for example, text entered in a text field—through controller objects to an application’s model objects. Controller ObjectsA controller object acts as an intermediary between one or more of an application’s view objects and one or more of its model objects. Controller objects are thus a conduit through which view objects learn about changes in model objects and vice versa. Controller objects can also perform setup and coordinating tasks for an application and manage the life cycles of other objects. Communication: A controller object interprets user actions made in view objects and communicates new or changed data to the model layer. When model objects change, a controller object communicates that new model data to the view objects so that they can display it.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Delegate]]></title>
    <url>%2FiOS%2FDelegate.html</url>
    <content type="text"><![CDATA[DefinationThe delegate is an object(Control Object) that executes a group of methods on behalf of another object. Control object is designed to pass user input to a data model. We want view classes to be used as is, and then we want control and model classes to have the freedom to customize those views. The delegate pattern allows for this. The key to the delegate pattern, is that the view establishes the questions that it needs answered and encodes them in a protocol. A protocol is a list of methods that a delegate must implement. Any object that fulfills the protocol can become a delegate. UITextFieldDelegate protocolLet’s take a closer look at the protocol we’ll implement next, the UITextFieldDelegate protocol. We’ve listed its methods below. For each of the seven methods, consult the documentation and provide an example implementation. Post one or two of your examples to the discussion forum. Editing lifecycle methods:textFieldShouldBeginEditing(_:)textFieldDidBeginEditing(_:)textFieldShouldEndEditing(_:)textFieldDidEndEditing(_:) textFieldShouldBeginEditing(_:) You could use this method to prevent the user from editing the text field’s contents more than once. textFieldDidBeginEditing(_:) You might use this method to show overlay views that are visible only while editing. textFieldShouldEndEditing(_:) The text field calls this method when it is asked to resign the first responder status. This can happen when the user selects another control or when you call the text field’s resignFirstResponder() method. Before the focus change occurs, however, the text field calls this method and gives you a chance to prevent the change from happening. Normally, you would return true from this method to allow the text field to resign the first responder status. You might return false, however, in cases where your delegate detects invalid contents in the text field. Returning false prevents the user from switching to another control until the text field contains a valid value. If you use this method to validate the contents of the text field, you might also want to use an overlay view to provide feedback to that effect. For example, you might display a small icon indicating the text is invalid. textFieldDidEndEditing(_:) This method is called after the text field resigns its first responder status. You can use this method to update your delegate’s state information. For example, you might use this method to hide overlay views that should be visible only while editing. The primary method for controlling text:textField(_:shouldChangeCharactersIn:replacementString:) textField The text field containing the text. range The range of characters to be replaced. string The replacement string for the specified range. During typing, this parameter normally contains only the single new character that was typed, but it may contain more characters if the user is pasting text. When the user deletes one or more characters, the replacement string is empty. The text field calls this method whenever user actions cause its text to change. Use this method to validate text as it is typed by the user. For example, you could use this method to prevent the user from entering anything but numerical values. The clear button (the ‘x’ on the right side of some text fields):textFieldShouldClear(_:) The text field calls this method in response to the user pressing the built-in clear button. (This button is not shown by default but can be enabled by changing the value in the clearButtonMode property of the text field.) This method is also called when editing begins and the clearsOnBeginEditing property of the text field is set to true. If you do not implement this method, the text field clears the text as if the method had returned true. The return key in the keyboard:textFieldShouldReturn(_:) The default implementation returns true, resigning first responder status. You can override this method in your custom responders to update your object’s state or perform other actions, such as removing the highlight from a selection. You can also return false, refusing to relinquish first responder status. If you override this method, you must call super (the superclass implementation) at some point in your code. Control Flow Walk-trough User taps keyboard Textfield realizes text will change Textfield invokes … textField(_:shouldChangeCharactersIn:replacementString:) VC receives invocation VC assembles the new text VC updates the label VC returns “true” to allow change 123456789101112131415161718192021// MARK: Text Field Delegate Methods// Step 4func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123; // Step 5 // Figure out what the new text will be, if we return true var newText = textField.text! as NSString newText = newText.replacingCharacters(in: range, with: string) as NSString // hide the label if the newText will be an empty string self.characterCountLabel.isHidden = (newText.length == 0) // Step 6 // Write the length of newText into the label self.characterCountLabel.text = String(newText.length) // Step 7 // returning true gives the text field permission to change its text return true;&#125; We can’t see the first three steps. Emoji Textfield123456789101112131415161718192021222324252627282930313233343536373839func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123; var replacedAnEmoji = false var emojiStringRange: NSRange // Construct the text that will be in the field if this change is accepted var newText = textField.text! as NSString newText = newText.replacingCharacters(in: range, with: string) as NSString // For each dictionary entry in translations, pull out a string to // search for an emoji to replace it with for (emojiString, emoji) in translations &#123; // Search for all occurances of key (ie. "dog"), // and replace with emoji (ie. 🐶) // repeat-while loop repeat &#123; emojiStringRange = newText.range(of: emojiString, options: .caseInsensitive) // found one if emojiStringRange.location != NSNotFound &#123; newText = newText.replacingCharacters(in: emojiStringRange, with: emoji) as NSString replacedAnEmoji = true &#125; &#125; while emojiStringRange.location != NSNotFound &#125; // If we have replaced an emoji, then we directly edit the text field // Otherwise we allow the proposed edit. if replacedAnEmoji &#123; textField.text = newText as String return false &#125; else &#123; return true &#125; &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift进阶]]></title>
    <url>%2FiOS%2FSwift%E8%BF%9B%E9%98%B6.html</url>
    <content type="text"><![CDATA[OptionalsNil valueThe Nil value is the same as null in some other languages. 12345678910111213141516171819202122var z: Int?var s: Strings = "123"z = Int(s)var zee: Int?var string: Stringlet randomNumber = Int(arc4random() % 2)if randomNumber == 1 &#123; string = "123"&#125; else &#123; // always 0 string = "ABC"&#125;zee = Int(string)if let intValue = zee &#123; intValue * 2&#125; else &#123; "No value"&#125; Another Example With Nested StructuresSafely unwrapping optionals is a fundamental Swift skill and one can’t have too much practice. Let’s walk through another example using the following enum and structures. 1234567891011121314enum Genre: String &#123; case country, blues, folk&#125;struct Artist &#123; let name: String var primaryGenre: Genre?&#125;struct Song &#123; let title: String let released: Int let artist: Artist?&#125; The Song struct contains a property artist of optional type Artist?. Then, the Artist struct as a primaryGenre property of optional type Genre?. Genre is a simple enumeration with only three cases for simplicity. Now imagine we have the following instances of the Artist and Song structs. Here, johnny is assigned to the Artist property of walkTheLine. 12var johnny = Artist(name: "Johnny Cash", primaryGenre: Genre.country)var walkTheLine = Song(title: "I Walk the Line", released: 1956, artist: johnny) If we only had access to the the Song instance walkTheLine and we wanted to determine the primaryGenre of the song’s artist, we’d need some if lets. First, we’d need to get the artist. 12345if let artist = walkTheLine.artist &#123; print(artist.name)&#125; else &#123; print("Artist unknown")&#125; And within the first if let, we’d use another to get the primaryGenre. 12345678910if let artist = walkTheLine.artist &#123; if let genre = artist.primaryGenre &#123; // If there is no value for enum, it wll be "country" print("Primary genre: \(genre.rawValue)") &#125; else &#123; print("Primary genre unknown") &#125;&#125; else &#123; print("Artist unknown")&#125; If the genre property of artist is not nil, we know it has a value and can safely print out the genre. Example: Animals With and Without TailsHere’s another example: let’s say we have a struct called Animal. The Animal struct has a tail property and the tail property is an optional — not all animals have tails. 1234567891011121314151617181920212223struct Tail &#123; var length: String init(length: Int) &#123; self.length = "\(length)" &#125;&#125;struct Animal &#123; var name:String var species: String = "homo sapiens" var tail: Tail? init(name: String, species: String, tailLength:Int?) &#123; self.name = name self.species = species if let tailLength = tailLength &#123; self.tail = Tail(length: tailLength) &#125; else &#123; self.tail = nil &#125; &#125;&#125; 12345678var animal = Animal(name: "Lenny", species: "lemur", tailLength: 12)if let tailLength = animal.tail?.length&#123; print("\(animal.name)'s tail is \(tailLength) cm long")&#125; else &#123; print("\(animal.name) doesn't have a tail.")&#125;// "Lenny's tail is 12 cm long\n" 12345678var animal = Animal(name: "Gilbert", species: "Gorilla", tailLength: nil)if let tailLength = animal.tail?.length&#123; print("\(animal.name)'s tail is \(tailLength) cm long")&#125; else &#123; print("\(animal.name) doesn't have a tail.")&#125;// "Gilbert doesn't have a tail.\n" Nil Coalescing OperatorWe already used optional chaining to avoid nesting if lets, but what if all we want to do is provide tailLength with a default value if the optional chaining fails? Swift provides a useful operator, for situations like these, the nil coalescing operator, ??. 1&lt;optional expression&gt; ?? &lt;default case&gt; To use the operator, simply place ?? after the optional chaining expression, and then put a default value after the ??. 123let tailLength = animal.tail?.length ?? "0"print("tail length: \(tailLength)")// tail length: 0 Your TurnAssume the following structs and enum are defined. 1234567891011121314enum Genre: String &#123; case country, blues, folk&#125;struct Artist &#123; let name: String var primaryGenre: Genre?&#125;struct Song &#123; let title: String let released: Int var artist: Artist?&#125; Using the enums and structures, implement the getArtistGenre() function. Given a Song as input, return the raw value of the artist’s primary genre. If either the artist is nil or the primaryGenre is nil, then return an empty string. You must use optional chaining and the nil coalescing operator (??). 1234567891011121314151617181920212223242526272829enum Genre: String &#123; case country, blues, folk&#125;struct Artist &#123; let name: String var primaryGenre: Genre?&#125;struct Song &#123; let title: String let released: Int var artist: Artist?&#125;func getArtistGenre(song: Song) -&gt; String &#123; if let songGenre = song.artist?.primaryGenre &#123; return songGenre.rawValue &#125; else &#123; let songGenre = song.artist?.primaryGenre?.rawValue ?? "" return songGenre &#125;&#125;var artisTest = Artist(name: "name", primaryGenre: nil)var test = Song(title: "title", released: 2021, artist: artisTest)print(getArtistGenre(song: test)) Example: Revisiting the Int() Initializer MethodLet’s say we’re using the Int() initializer method and invoking it on a variable that we are confident can be converted to an Int. 1let w = Int("123") We know this method is going to return the Int, 123, so in this case, unwrapping with the exclamation point is appropriate. We know there is little risk of a fatal error being thrown. We can place the exclamation point after w, like this: 1w! * 2 Or we could unwrap the return value directly, like this: 12let w = Int("123")!w * 2 In this second case the value assigned to w will be a plain old Int. Implicitly Unwrapped Optionals: Revisiting the Villain structWhat about declaring implicitly unwrapped optionals? When is an appropriate time to be so bold? Well, remember the evilScheme property of the Villain struct? We wanted the ability to create instances of Villain with the option of not providing an evilScheme at first. However, once we know that the evilScheme has been set, we can access the property as if it were a regular non-optional type. 123456789101112131415struct Villain &#123; let name: String // exclamation point means implicitly unwrapped var evilScheme: String! func performScheme() &#123; // no unwrapping necessary print("And now, I will \(evilScheme!)") &#125;&#125;var villain = Villain(name: "Billy", evilScheme: nil)villain.evilScheme = "steal from the cookie jar"// we know for sure the scheme has been setvillain.performScheme() There are a few things to note in the example above. The evilScheme property is now declared as an implicitly unwrapped optional. It’s type is written as String! instead of String?. In the performScheme() method, we reference evilScheme as any other property, without unwrapping. We call performScheme() once we know for a fact that evilScheme was set. The function assumes that evilScheme is not nil. If we treat an implicitly unwrapped optional that contains nil as if it contained a value, bad things can happen - including crashes! Difference between upwrapping an with ?, with ! and with implicit unwrapping?Unwrapping with ? is useful if you’re accessing nested properties or want some default behavior to occur if a value is nil. Using ! does not require providing a default value and is useful if you know that a value won’t be nil. However, if it is nil, the program will crash. Implicitly unwrapping optionals is also useful when you know a value won’t be nil, but you can use the same syntax as a normal property. However, unintended behavior and crashes can occur if it is nil. StringsA String is a StructYou just saw how a string can be initialized without a string literal. 1let stringWithPotential = String() Counting CharactersLet’s start with something straightforward. If you want to know how many characters are in a string, you use the count property. 12var str = "Meet me in St. Louis!""The string is \(str.count) characters long" Many real apps rely on counting characters - for example, a Twitter client that ensures a user is restricted to typing 140 or fewer characters. Accessing specific charactersWe can also conveniently access the characters at the beginning and end of a string. 12let firstLetter = str.firstlet isExcited = str.last == "!" Checking for SubstringsA substring is the term programmers use for any string that occurs within another string. We can check for the presence of a substring in different cases as shown below. 123str.contains("Lou")str.hasPrefix("Me")str.hasSuffix("in") contains() simply checks if the substring occurs anywhere in str. hasPrefix() and hasSuffix() are more specialized and check if the substring occurs at the beginning and end of the string respectively. Creating Variations of StringsWe can also use some string methods to generate different strings. 123str.lowercased()str.uppercased()String(str.reversed()) Converting strings to all-lowercase or all-uppercase is great when you want user input to be case-insensitive. And reversing a string is useful if you want to see if two strings are palindromes. Note in the last example, we need to use str.reversed() with a String initializer. If you look closely at the documentation for reversed(), you’ll see that it actually returns a ReversedCollection instead of a String. You won’t need to use this type directly, but just know that Swift uses it “under the hood” for efficiency. You can simply use the String() initializer to convert the result into a usable string. Appending Two StringsSimilar to concatenation, String also has an append() method that takes a string as an argument and attaches it to the string you’re mutating. 123var hello = "hello "let world = "world!"hello.append(world) Is the equivalent of 1hello = hello + world or 1hello += world With append() you don’t need to reassign hello a new value, and you’ll find the code is much more readable. Trimming charactersIn addition to append(), we can also remove characters from the end of a string. For example, you may want to remove all whitespace characters from the end of a user’s input. 12345var message = " Be back later! "while message.last == " " &#123; message.removeLast()&#125; And the same can be done at the beginning. 123while message.first == " " &#123; message.removeFirst()&#125; Replacing SubstringsWe can also modify the middle of strings. A common manipulation method is replacingOccurrences(of: String, with: String), which allows us to swap out one substring with another. 12let verbose = "We hope you are very excited to learn Swift. It's a very fun and very useful skill. Soon enough, you'll be writing your very own app!"let better = verbose.replacingOccurrences(of: "very ", with: "") This method might come in handy for implementing a Find and Replace feature, a profanity filter, and many other cases, and is great to have in your string manipulation bag of tricks. Note: To use the replaceOccurrences() method, you will need to add import Foundation to the top of your file. Foundation is a framework, which is just a name for a collection of commonly used code. Apple provides frameworks like Foundation so that developers, like you, don’t need to reinvent the wheel for common tasks like string manipulation. We’ve already imported Foundation in the playground, so you can just follow along with the examples. ArrayInitialize 12345678910111213141516171819202122232425//: ## Initializing Arrays//: The verbose wayvar numbers = Array&lt;Double&gt;()//: More often you will see ...var moreNumbers = [Double]()moreNumbers = [85.0, 90.0, 95.0]//: Array literal syntaxlet differentNumbers = [97.5, 98.5, 99.0]//: Array concatenation is super convenient in SwiftmoreNumbers += differentNumbers//: ## Swift Arrays have types//: An array can hold any type of objectstruct LightSwitch &#123; var on: Bool = true&#125;var circuit = [LightSwitch]()var livingRoomSwitch = LightSwitch()var kitchenSwitch = LightSwitch()var bathroomSwitch = LightSwitch()circuit = [livingRoomSwitch, kitchenSwitch, bathroomSwitch] Append Here is an array of type String, listing musicians we want to play in the car on our upcoming road trip. To add an item to the end of an array we can use the append method, like this: 12var musicians = ["Neil Young", "Kendrick Lamar", "Flo Rida", "Fetty Wap"]musicians.append("Rae Sremmurd") The array now looks like this: 1["Neil Young", "Kendrick Lamar", "Flo Rida", "Fetty Wap", "Rae Sremmurd"] Insert To add an item to a specific place in an array we can use the method, insert(at:). So, to add in “Dej Loaf” at index 2 we would write the following: 1musicians.insert("Dej Loaf", at: 2) The array now looks like this: 1["Neil Young", "Kendrick Lamar", "Dej Loaf", "Flo Rida", "Fetty Wap", "Rae Sremmurd"] Remove We can use a method called remove(at:) to remove an item at a particular index. If we remove the item at index 3, you can see that “Flo Rida” is removed: 1musicians.remove(at: 3) Subscripting Finally, if you want to retrieve an item at a particular index, you can use subscript syntax. Simply put the index in-between brackets after the array name, like so: 1let musician = musician[2] DictionaryInitialize12345// Initializer syntaxvar groupDict = [String:String]()// Dictionary literalvar animalGroupDict = ["whales":"pod", "geese":"flock", "lions": "pride"] 12345678910111213141516171819202122232425262728293031323334353637//: ## Dictionary operations//: insert, count, remove, update, retrievevar animalGroupsDict = ["whales":"pod", "geese":"flock", "lions": "pride"]//: Adding items to a dictionaryanimalGroupsDict["crows"] = "murder"animalGroupsDict["monkeys"] = "troop"//: The count method is available to all collections.animalGroupsDict.count // 5print(animalGroupsDict)//: Removing items from a dictionaryanimalGroupsDict["crows"] = nilanimalGroupsDict//: Updating a valueanimalGroupsDict["monkeys"] = "barrel"var group = animalGroupsDict.updateValue("gaggle", forKey: "geese")type(of: group)animalGroupsDict.updateValue("crash", forKey: "rhinoceroses")print(animalGroupsDict)//: ## Example//: Retrieving the value for a particular keylet groupOfWhales = animalGroupsDict["whales"]//: Why would the code below return an optional?//://: animalGroupsDict["whales"]//: We unwrap a value returned from a dictionary just like we would unwrap any other optional.if let groupOfWhales = animalGroupsDict["whales"] &#123; print("We saw a \(groupOfWhales) of whales from the boat.")&#125; else &#123; print("No value found for that key.")&#125;//: What happens if the key isn't found?if let groupOfSasquatches = animalGroupsDict["Sasquatches"] &#123; print("We saw a \(groupOfSasquatches) of Sasquatches on our hike.")&#125; else &#123; print("No value found for that key.")&#125; Here we use the removeValueForKey() method to remove the value for the string, “George Bush”. Since removeValueForKey() returns the value removed, we can reset the value of the new key, “George H. W. Bush” to be the previously returned value, “Miss Beazley.” 12var oldValue = presidentialPetsDict.removeValueForKey("George Bush")presidentialPetsDict["George W. Bush"] = oldValue We unwrap the retrieved value using if let and then use string interpolation to insert “Bo” into the string. The string is printed out as a part of the if block. 12345if let dog = presidentialDogs["Barack Obama"] &#123; print("Michele Obama walks \(dog) evey morning.")&#125; else &#123; print("No value found.")&#125; Sets123456789101112131415//: ## Sets//: Literal syntaxvar cutlery: Set = ["fork", "knife", "spoon"]var flowers:Set&lt;Character&gt; = ["🌷","🌹","🌸"]//: Initializer syntaxvar utensils = Set&lt;String&gt;()var trees = Set&lt;Character&gt;()//: ## Set operations//: Insert, Remove, Counttrees.insert("🌲")trees.insert("🌳")trees.insert("🌵")trees.remove("🌵")trees.count Class123456789101112131415161718192021222324252627282930313233343536class Movie &#123; let title: String let director: String let releaseYear: Int init(title: String, director: String, releaseYear: Int) &#123; self.title = title self.director = director self.releaseYear = releaseYear &#125;&#125;class MovieArchive &#123; var movies: [Movie] func filterByYear(year: Int) -&gt; [Movie] &#123; var filteredArray = [Movie]() for movie in self.movies &#123; if movie.releaseYear == year &#123; filteredArray.append(movie) &#125; &#125; return filteredArray &#125; init(movies: [Movie]) &#123; self.movies = movies &#125;&#125;let movie1 = Movie(title: "Bride of Frankenstein", director: "James Whale", releaseYear: 1935)let movie2 = Movie(title: "The Night Walker", director: "William Castle", releaseYear: 1964)let archive = MovieArchive(movies: [movie1, movie2])archive.filterByYear(year: 1935)archive.movies The difference between class and structOne important difference between structs and classes in Swift is how they’re handled in the computer or phone’s memory. Structs are passed by value while classes are passed by reference. 引用类型：将一个对象赋值给另一个对象时，系统不会对此对象进行拷贝，而会将指向这个对象的指针赋值给另一个对象，当修改其中一个对象的值时，另一个对象的值会随之改变。 值类型：将一个对象赋值给另一个对象时，会对此对象进行拷贝，复制出一份副本给另一个对象，在修改其中一个对象的值时，不影响另外一个对象。 Array is a type of Struct. Use array as an example. Each array has an independent value that includes the values of all of its elements. For simple types such as integers and other structures, this means that when you change a value in one array, the value of that element does not change in any copies of the array. For example: 1234567var numbers = [1, 2, 3, 4, 5]var numbersCopy = numbersnumbers[0] = 100print(numbers)// Prints "[100, 2, 3, 4, 5]"print(numbersCopy)// Prints "[1, 2, 3, 4, 5]" If the elements in an array are instances of a class, the semantics are the same, though they might appear different at first. In this case, the values stored in the array are references to objects that live outside the array. If you change a reference to an object in one array, only that array has a reference to the new object. However, if two arrays contain references to the same object, you can observe changes to that object’s properties from both arrays. For example: 12345678910111213141516171819// An integer type with reference semanticsclass IntegerReference &#123; var value = 10&#125;var firstIntegers = [IntegerReference(), IntegerReference()]var secondIntegers = firstIntegers// Modifications to an instance are visible from either arrayfirstIntegers[0].value = 100print(secondIntegers[0].value)// Prints "100"// Replacements, additions, and removals are still visible// only in the modified arrayfirstIntegers[0] = IntegerReference()print(firstIntegers[0].value)// Prints "10"print(secondIntegers[0].value)// Prints "100" Class InheritanceOne powerful feature of classes not available to structs is inheritance. Inheritance allows one class to take on the properties and methods of another class, as well as add its own functionality. To start, let’s say we have a Guitar class defined as the following. 12345678910111213class Guitar &#123; let strings: Int let frets: Int init(strings: Int, frets: Int) &#123; self.strings = strings self.frets = frets &#125; func pluckString() &#123; print("twang") &#125;&#125; This is a great start, but what if we then wanted to model an electric guitar. The electric guitar is a “kind of” guitar, but with a few differences. For example, the electric guitar has electronics for modifying the volume and tone of its output (check out the knobs on the lower body). We could define a new ElectricGuitar class by copy-pasting the GuitarClass and adding these different properties, but we can do much better. Instead, if we place a colon after the the class name and then specify the class we want to inherit from, the ElectricGuitar automatically has all the properties and methods of a guitar. 1234class ElectricGuitar: Guitar &#123; var volumeLevel: Float = 1.0 var toneLevel: Float = 1.0&#125; Now we have a new class, ElectricGuitar that has all the properties of Guitar with the additional properties for volume and tone. Class Description superclass A class that is inherited from subclass A class that inherits from another class (the superclass) parent class A class’s superclass child class A class that descended (inherited directly) from a parent class. descendant A class that inherited from an ancestor ancestor A class that has child or descendent classes root class A class with no superclass leaf class A class with no subclasses hierarchy A tree of inheritance relationships Overriding MethodsInheritance doesn’t just let you add to a class - you can also override its behavior. For example, since an electric guitar’s volume affects its sound, we can provide some custom functionality to the pluck() method. 12345678910override func pluckString() &#123; if volumeLevel &gt; 0.7 &#123; print("🎸🎸🎸 DRAOWWW") &#125; else if volumeLevel &gt; 0 &#123; print("🎸 twang") &#125; else &#123; // volumeLevel is 0 // Guitar's implementation of pluckString() super.pluckString() &#125;&#125; Overriding a method is as simple as redeclaring it and adding the override keyword before func. And if you ever need to fall back to the original functionality, as we do in the case when the volume is 0, the old implementation can be called super keyword. super just refers to the superclass (the Guitar class we’re inheriting from) so super.pluck() will call the pluck() method of theGuitar` class which will print “twang”. PolymorphismInheritance, or the ability of one class to take on the properties and methods of a superclass, leads us to the next topic - polymorphism. Polymorphism means “many forms.” It is a programming language feature by which a type can be substituted for another type. For example, since it inherits from a Guitar, an ElectricGuitar can be substituted anywhere that a Guitar would be used. In other words, an ElectricGuitar is a form of Guitar. Polymorphism allows for simpler code that avoids unnecessary specificity, and code that is flexible and expandable because it’s applicable to more than one type. If we were to add additional subclasses of Guitar, we could still use any of these types where a Guitar is used. override is used to indicate that a subclass’s method implementation will be substituted for a superclass’s method implementation. This is an aspect of polymorphism through inheritance. We saw an example of polymorphism previously when we used override to refer to a single Guitar type, and produced different behavior by substituting in an ElectricGuitar instead of a Guitar. We can see an example of polymorphism in action below. Because anyGuitar‘s type is Guitar we can assign any subclass of Guitar, including an ElectricGuitar to that variable. 12345var anyGuitar: Guitar = Guitar(strings: 6, frets: 20)anyGuitar.pluckString()anyGuitar = ElectricGuitar(strings: 6, frets: 20)anyGuitar.pluckString() Even though anyGuitar()‘s type is still Guitar, calling pluckString() will call the custom method we defined for ElectricGuitar. As a result, we can keep our code involving Guitar instances reusable, without sacrificing the functionality of any subclasses that happen to override a method. Type CastingFinally, if we know that anyGuitar is assigned an ElectricGuitar and we want to access the toneLevel property, we can convert the types with a special keyword: as. When using the as keyword the variable you want to convert goes on the left and the type you’re converting to goes on the right. 12345678result = variableToConvert as NewType// forcibly convert the types with &quot;as!&quot;let electricGuitar = anyGuitar as! ElectricGuitarelectricGuitar.toneLevel// or safely convert with &quot;if let&quot; with &quot;as?&quot;if let electricGuitar = anyGuitar as? ElectricGuitar &#123; electricGuitar.toneLevel&#125; You’ll also notice the use of as! and as? in this example. This may seem complicated but it’s really the same concept you learned about unwrapping optionals. Since there’s no guarantee that anyGuitar will actually be an ElectricGuitar, casting to an ElectricGuitar returns an optional of type Guitar?. To forcibly unwrap the result, we use as! and to conditionally unwrap with if let, we use as?. Defining TermsThere’s some terminology to cover, and then we’ll describe what happens when a method is called on a type that is defined as a class. Term Example Definition instance Guitar() A class or type that we have initialized. Can be referred to with a constant or variable, and refers to its own instance with self override override func pluckString() { } Used to indicate that this method implementation should supersede the superclass’s method implementation super super.someMethod() Used to retrieve and invoke a method implementation that has been overridden Protocols123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Initprotocol Souschef &#123; func chop(vegetable: String) -&gt; String func rinse(vegetable: String) -&gt; String&#125;class Roommate: Souschef, Equatable &#123; var hungry = true var name: String init(hungry: Bool, name: String) &#123; self.hungry = hungry self.name = name &#125; func chop(vegetable: String) -&gt; String &#123; return "She's choppin' \(vegetable)!" &#125; func rinse(vegetable: String) -&gt; String &#123; return "The \(vegetable) is so fresh and so clean" &#125;&#125;// implete the function outside the classfunc ==(lhs: Roommate, rhs: Roommate) -&gt; Bool &#123; return lhs.name == rhs.name &amp;&amp; lhs.hungry == rhs.hungry&#125;var roomie = Roommate(hungry: true, name: "Jennifer")var theBestRoomie = Roommate(hungry: true, name: "Jennifer")roomie == theBestRoomie//: ## A protocol is also a type, any class that adopts this protocolclass DinnerCrew &#123; var members: [Souschef] init(members: [Souschef]) &#123; self.members = members &#125;&#125;class RandomPasserby: Souschef &#123; var name: String init(name: String) &#123; self.name = name &#125; func chop(vegetable: String) -&gt; String &#123; return "She's choppin' \(vegetable)!" &#125; func rinse(vegetable: String) -&gt; String &#123; return "The \(vegetable) is so fresh and so clean" &#125;&#125;var newFriend = RandomPasserby(name: "Dave")var motleyDinnerCrew = DinnerCrew(members: [newFriend, roomie]) ExtensionsOne more powerful feature of Swift types is the ability to add new methods and properties through extensions. You’ll see extensions in action as you start building the Pitch Perfect app, so let’s take a look at an example before wrapping up with object oriented programming. To extend a class, simply use the extension keyword, followed by the type name. 1extension SomeClass &#123; ... &#125; Additionally, you can also add a colon after the type name followed by any number of protocols you’d like the type to conform to. Let’s rewrite the Roommate example so that it uses an extension to conform to Souschef. 123456789extension Roommate: Souschef &#123; func chop(vegetable: String) -&gt; String &#123; return "She's choppin' \(vegetable)!" &#125; func rinse(vegetable: String) -&gt; String &#123; return "The \(vegetable) is so fresh and so clean" &#125;&#125; Isn’t this the same as the previous example? It is, but with extensions, you don’t even need access to the original class definition for Roommate. As you begin your journey into iOS development, you’ll be working with many classes provided by Apple in which you do not have direct access to the code. However, with extensions you can add functionality to these types without ever modifying the original class definition. ReviewSomething that is passed by value such as an instance of a struct is copied when it’s assigned to a variable or passed to a function. Changing a property on the instance will only apply to the copy, and the original instance will remain unchanged. Values that are passed by reference, such as instances of classes, are not copied. Changing a value on a copy will also modify the original instance, since the copy is simply referencing the original.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift初探]]></title>
    <url>%2FiOS%2FSwift%E5%88%9D%E6%8E%A2.html</url>
    <content type="text"><![CDATA[Variables and TypesHello world!12var question = "Hello world!"print(question) Comments123456789// this is a comment/* this is a multiline comment *//*print("neither will this")print("or this")*/ Data types Type Description Example Values Int whole number values 0, 2, -2, 100, … Float floating-point (decimal) numbers that require no more than 6 decimal digits (32-bit) 3.14, 5.693, -12.321, … Double floating-point (decimal) numbers that require more precision—guaranteed 15 decimal digits (64-bit) 3.14, 5.693, -12.321, … Bool a Boolean truth value true, false Character a single letter, digit, symbol, or code “a”, “+”, “q”, … String combinations of characters “swift”, “I Love Swift”, “ “, “:)”, … Creating variables123456var numberOfWheels: Int = 4var centimetersOfRainfall: Float = 5.5var pi: Double = 3.14159265359var letterOfTheDay: Character = "z"var myFavoriteAnimal: String = "octopus"var rainingOutside: Bool = true The code below is also okay, because Siwft can infer what is the type of the variable. 1var firstName = "Aisha" Change the value of the variable, but we can’t change the type of the vcariable. 1234// initial declaration of petsAgevar petsAge = 12petsAge = 13 Constant. 123let encouragement = "You can do it!"var customizedEncouragement = "You can do it, Stephanie!"customizedEncouragement = "You can do it, Ryder!" String. 1let emailSignature = "Aliyah Smith\nVP, Sales\n(555) - 555 - 5555" Character Usage \n Newline / line feed \t Horizontal tab &quot; Double quotation mark, using &quot; alone signifies the end of a string &#39; Single quotation mark \ Backslash, using “&quot; alone escapes the next character 12var a = "Happy birthday, \("Maverick")!"print(a) Operators and Expressions12345675 / 3 // The result is 15 / 3.0 // The result is 1.66666667var hello = "Hello"var world = "world!"let greeting = hello + " " + world Ternary OperatorsTernary operator : an operator that is applied to three operands Ternary operators are much less common than binary operators, but one of the most common ternary operators is the ternary conditional operator. It is used to choose between two values based on a truth (Boolean) value, and it uses the following syntax: 1trueOrFalseValue ? useThisIfTrue : useThisIfFalse Control Flow12345678910111213141516171819202122232425262728293031323334if onGuestList &amp;&amp; age &gt;= 21 &#123; print("\(name), come party with us!")&#125;if !onGuestList || age &lt; 21 &#123; print("Sorry, \(name), maybe you can go play Bingo with the Android team.")&#125;if breakfast &#123; print("Good morning!")&#125; else if lunch &#123; print("Good afternoon!")&#125; else if dinner &#123; print("Good evening!")&#125; else &#123; print("Hello!")&#125;switch month &#123;case 1: print(“January”)case 2: print(“February”)// ...&#125;let meal = "breakfast"switch meal&#123; case "breakfast": print("Good morning!") case "lunch": print("Good afternoon!") case "dinner": print("Good evening!") default: print("none")&#125; 123456789101112131415161718192021221...10 // 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.1..&lt;10 // 1, 2, 3, 4, 5, 6, 7, 8, 9.for i in 1...10&#123; print(i)&#125;var i = 1while (i&lt;1001)&#123; if (i % 2) == 0&#123; print(i) &#125; i += 1&#125;// repeat-while loopvar i = 1repeat &#123; print("Hello, world!") i += 1&#125; while i &lt; 0 Functions12345678910111213141516171819202122232425262728293031323334353637383940414243func printLove(s: String)&#123; print("I love \(s)")&#125;printLove(s: "Swift")func printLove(s: String)&#123; print("I love" + s)&#125;printLove(s: "Swift")func areaOfRectangle(length: Int, width: Int)&#123; print(length * width)&#125;areaOfRectangle(length: 2, width: 5)func calculateTip(priceOfMeal: Double) -&gt; Double &#123; return priceOfMeal * 0.15&#125;func isPastBedtime(hour: Int) -&gt; Bool &#123; if hour &gt; 9 &#123; return true &#125; else &#123; return false &#125;&#125;func addValues(value1 x: Int, value2 y: Int) -&gt; Int &#123; // internally, use `x` and `y` return x + y&#125;// externally, use `value1` and `value2`addValues(value1: 5, value2: 10)func addExcitementToString(_ string: String) -&gt; String &#123; return string + "!"&#125;addExcitementToString("Swift") Structures and Enums123456789101112131415161718192021222324252627282930313233343536373839struct Student &#123; let name: String var age: Int var school: String&#125;var ayush = Student(name: "Ayush Saraswat", age: 19, school: "Udacity")struct Beaker &#123; var volumeMilliliters: Double func canContainContents(otherBeaker: Beaker) -&gt; Bool &#123; return volumeMilliliters &gt;= otherBeaker.volumeMilliliters &#125;&#125;let beaker1 = Beaker(volumeMilliliters: 500)let beaker2 = Beaker(volumeMilliliters: 1000)let canContainContents: Bool = beaker1.canContainContents(otherBeaker: beaker2)// If, however, a method tries to modify (or mutate) one of the struct's properties, then the mutating keyword must be added before func. For examplemutating func increaseCapacity() &#123; volumeMilliliters += 500&#125;struct Beaker &#123; let volumeMilliliters: Double static var madeIn = "China" // These are US ounces var volumeOunces: Double &#123; return volumeMilliliters * 0.033814 &#125; func canContainContents(otherBeaker: Beaker) -&gt; Bool &#123; return volumeMilliliters &gt;= otherBeaker.volumeMilliliters &#125;&#125;// In fact, when we change the value of a static property with dot notation, we reference the type name and not a specific instance (Beaker.madeIn). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748enum PrimaryColor &#123; case red case blue case yellow&#125;enum Aunties &#123; case aime, billie, diane, gail, janie, pam&#125;enum DrinkSize: Int &#123; case small = 12 case medium = 16 case large = 20&#125;// rawValueVar sugar = "A \(DrinkSize.small.rawValue) oz Coke has 33 g of sugar"// "A 12 oz Coke has 33 g of sugar"// Using 'enum' with 'switch'enum Finger: Int &#123; case thumb = 1 case index = 2 case middle = 3 case ring = 4 case pinky = 5&#125;var destination = Finger.thumbvar test = Finger(rawValue: 3)// switch destinationswitch test &#123; case .thumb: print("thumb") case .index: print("index") case .middle: print("middle") case .ring: print("ring") case .pinky: print("pinky") // We need to use none for 'test' case .none: print("None!")&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UCSD EC80 选课]]></title>
    <url>%2FOtherArticle%2F%E5%9B%9B%E5%AD%A6%E6%9C%9F%E8%AF%BE%E7%A8%8B%E5%AE%89%E6%8E%92.html</url>
    <content type="text"><![CDATA[SEASON CLASS_1 CLASS_2 CLASS_3 FALL ECE269 CSE252A CSE258 WINTER ECE276A ECE141A ECE143 SPRING ECE272A ECE141B CSE240 FALL ECE271A CSE250 ECE250 FALL 2021:ECE 269: Linear Algebra and Application (Piya Pal)Class GPA: ( students)Stats: A+ (0%), A (5.9%, 11), A- (7.5%, 14), B+ (23.7%,44), B (16.1%, 30), B- (30.6%, 57), C+ (9.7%, 18) …Weights: Quiz (20%), Final (35%), Assignments (45%)Comments:由于EC80的专业特性，毕业要求四门核心课，所以如果想要在一学期之内毕业，就必须要每学期选一门。根据往届的信息，ECE269这门课是所有四门课程中相对简单的，毕竟本科都有点线性代数的基础（对于我来说等于没学）。作为第一学期的核心课，我自认为还是比较认真的，上课次次不落，discussion也每次都去，课后也会复习笔记，因为有些内容真的没有完全听懂。作业的话由于自己马虎，加上有些题目确实不会，导致分数也不理想，都在medium附近徘徊。两个quiz，第一个quiz难度还算可以，第二个quiz难度飙升，三道题目就对了一个。到了期末就更惨了，6道题只会两个半道，到现在我还不知道能打多少分。毕竟这门课是个comprehensive的课程，要达到一定标准才能毕业，再加上GPA 3.0才能达到毕业要求，让这个等待出分的我非常的慌张。 CSE252A: Computer Vision I (Ben Ochoa)]]></content>
      <categories>
        <category>UCSD</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LAIOFEER公开课]]></title>
    <url>%2FOtherArticle%2FLAIOFEER%E5%85%AC%E5%BC%80%E8%AF%BE.html</url>
    <content type="text"><![CDATA[Always put yourself in other people’s shoes. 换位思考 Critical thinking 任何事情并不是非黑即白 BQ question 1Tell me about yourself: Name, Education, Background Skills: Primary programming language, Projects experience, intern experience Thank you Variants: Tell me your weakness(e.g. 多任务同时处理，优先级问题) 承认自己的问题，尽量真实 Key points: How to avoid/address the same problems in the future. BQ question 2When you have different opinions from your colleagues Scenarios Communication: 1 on 1 不在公共场合批评别人; How/When/Where BQ question 3When you have limited time available to finish your project. Quality vs Speed 分情况讨论，用项目举例 Variant 1:Provide an example scenario in which you made a quick decision under pressure Variant 2: Write an email to your manager on how to explain why you missed the deadline BQ question 4What is your career plan for the next 5 years? 现在有什么，未来期待什么，怎么做？ concrete example BQ question 5How do you define a good manager? Or what do you expect from your manager? grow path BQ question 6Please tell me one of the most challenging projects you have accomplished. Why is it challenging？ Technical Human resource Operational complexity/ cost Novelty Time constraints How did you solve it? How did you evaluate the results? Scope/Impact 择高处立，就平处坐，向宽处行；立上等志，行中等事，享下等福。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>找工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[托福备考指北]]></title>
    <url>%2FOtherArticle%2F%E6%89%98%E7%A6%8F%E5%A4%87%E8%80%83%E6%8C%87%E5%8C%97.html</url>
    <content type="text"><![CDATA[成绩说来惭愧，考了3年托福，一共四次，最终还是在临近申请前的不到一个月考出的分，而且分数也只是刚刚过百（见下图），尽管最终成绩很低，但我也有一些经验和心得与各位分享，当然，也会有一些我认为比较好的学习资源通过百度云的方式供大家学习。 学习顺序与学习时间对于理工科学生，强烈建议先学习GRE。理由有以下几点： GRE的数学对于理工科学生难度不高，不需要太多准备； GRE的verbal部分以背单词为主，这部分单词并不需要托福单词为基础，如果这部分单词搞定了，学托福难度会明显降低不少； GRE提分较快，只要刷题就会看到成效，不存在原地踏步的情况，适合初期准备。 但无论是托福和GRE我的建议都是利用暑假、寒假大块时间准备，切忌将学习英语的时间与上课/实习等杂糅在一起，这样不但英语能力不会很快见效，而且还会影响课内的学习成绩。总之用一个1-2个月的空闲时间全力学习英语之后考试一定是最高效的。 托福单词回归到托福学习。学习英语无论怎样最重要的还是背单词，单词积累的到位了，看文章听听力等自然得心应手，我比较明显的体会是在我单词掌握不扎实的时候看托福阅读都是不知所云的，仿佛在看一段加了密的文字，但在我学习GRE后，单词量得到了较大的提升，看托福阅读速度明显加快，读了一遍后内容也达到了其义自见的程度（再次说明先学GRE的好处），但不能忽视的是，很多GRE的单词书并不涵盖托福需要掌握的重点词汇，更不能轻视的是很多重要的四六级词汇，它们既不会出现在托福单词书中也不会出现在GRE单词书中，但它们的出现频率却惊人的高，这些单词一定要及时弥补！ 分享两个比较好的单词书（pdf），提取码见评论区： 托福救命800词&amp;四六级救命800词 7天搞定托福单词]]></content>
      <categories>
        <category>出国经验分享</category>
      </categories>
      <tags>
        <tag>托福</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab机器人工具箱（Robotic Toolbox）仿真双六轴机械臂对侧打磨加工]]></title>
    <url>%2FRobotics%2FMatlab%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E5%85%B7%E7%AE%B1%EF%BC%88Robotic%20Toolbox%EF%BC%89%E4%BB%BF%E7%9C%9F%E5%8F%8C%E5%85%AD%E8%BD%B4%E6%9C%BA%E6%A2%B0%E8%87%82%E5%AF%B9%E4%BE%A7%E6%89%93%E7%A3%A8%E5%8A%A0%E5%B7%A5.html</url>
    <content type="text"><![CDATA[本任务为完成大三下学期机器人学课程讨论是所做实际上也是在之前做的双机仿真的基础上进行了修改。 最终结果如下： B站视频地址 使用的机器人工具箱版本为10.3.1版本 修改了工具箱自带的函数mdl_puma560，要使用代码需要在函数开头加上function p560 = mdl_puma560，结尾加上end以实现调用功能。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061%%close allclear;d = 0.2;plot3([0 0],[-1 1],[0 0])p560_1 = mdl_puma560;p560_1.name = 'puma1';p560_1.base = [-0.8 0 0];p560_2 = mdl_puma560;p560_2.name = 'puma2';p560_2.base = [0.8 0 0];t=0:0.05:2;%计算puma1机械臂移动到指定点，并将z轴指向朝前的齐次变换矩阵T1 = transl(-0.4,0.2,0.1);T2 = transl(0-d,-0.4,0)*troty(90);%计算puma2机械臂移动到指定点，z轴指向朝后的齐次变换矩阵T3 = transl(0.3,-0.3,0)*troty(-90);T4 = transl(0+d,-0.4,0)*troty(-90);%利用ctraj函数让两个机械臂运动到指定点m1=ctraj(T1,T2,length(t)/2);n1=ctraj(T3,T4,length(t)/2);q1=p560_1.ikine6s(m1);s1=p560_2.ikine6s(n1);%移动到指定点后沿直线移动T5 = transl(0-d,0.5,0)*troty(90);%puma1沿直线移动T6 = transl(0+d,0.5,0)*troty(-90);%puma2沿直线移动 m2=ctraj(T2,T5,length(t));n2=ctraj(T4,T6,length(t));y1=p560_1.ikine6s(m2);f1=p560_2.ikine6s(n2);%重复T7 = transl(0-d,0.5,0.2)*troty(90);T8 = transl(0+d,0.5,0.2)*troty(-90); m3=ctraj(T5,T7,length(t)/2);n3=ctraj(T6,T8,length(t)/2);q2=p560_1.ikine6s(m3);s2=p560_2.ikine6s(n3);T9 = transl(0-d,-0.4,0.2)*troty(90);T10 = transl(0+d,-0.4,0.2)*troty(-90);m4=ctraj(T7,T9,length(t));n4=ctraj(T8,T10,length(t));y2=p560_1.ikine6s(m4);f2=p560_2.ikine6s(n4);%画图p560_1.plot(q1);hold on;p560_2.plot(s1);hold on;p560_1.plot(y1);hold on;p560_2.plot(f1);hold on;plot3([0 0],[-1 1],[0.2 0.2])p560_1.plot(q2);hold on;p560_2.plot(s2);hold on;p560_1.plot(y2);hold on;p560_2.plot(f2);hold on; 由于Matlab无法实现双线程编程，所以并不是同步运动，所以考虑用循环的方式来实现“同步运动”，但本质上仍然不同步。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869%%close allclear;d = 0.2;plot3([0 0],[-1 1],[0 0])p560_1 = mdl_puma560;p560_1.name = 'puma1';p560_1.base = [-0.8 0 0];p560_2 = mdl_puma560;p560_2.name = 'puma2';p560_2.base = [0.8 0 0];t=0:0.05:2;%计算puma1机械臂移动到指定点，并将z轴指向朝下的齐次变换矩阵T1 = transl(-0.4,0.2,0.1);T2 = transl(0-d,-0.4,0)*troty(90);%计算puma2机械臂移动到指定点，z轴指向朝上的齐次变换矩阵T3 = transl(0.3,-0.3,0)*troty(-90);T4 = transl(0+d,-0.4,0)*troty(-90);%利用jtraj函数让两个机械臂运动到指定点m1=ctraj(T1,T2,length(t)/2);n1=ctraj(T3,T4,length(t)/2);q1=p560_1.ikine6s(m1);s1=p560_2.ikine6s(n1);%移动到指定点后沿直线移动T5 = transl(0-d,0.5,0)*troty(90);%puma1沿直线移动T6 = transl(0+d,0.5,0)*troty(-90);%puma2沿直线移动 m2=ctraj(T2,T5,length(t));n2=ctraj(T4,T6,length(t));y1=p560_1.ikine6s(m2);f1=p560_2.ikine6s(n2);%重复T7 = transl(0-d,0.5,0.2)*troty(90);T8 = transl(0+d,0.5,0.2)*troty(-90); m3=ctraj(T5,T7,length(t)/2);n3=ctraj(T6,T8,length(t)/2);q2=p560_1.ikine6s(m3);s2=p560_2.ikine6s(n3);T9 = transl(0-d,-0.4,0.2)*troty(90);T10 = transl(0+d,-0.4,0.2)*troty(-90);m4=ctraj(T7,T9,length(t));n4=ctraj(T8,T10,length(t));y2=p560_1.ikine6s(m4);f2=p560_2.ikine6s(n4);%画图for i=1:length(t)/2p560_1.plot(q1(i,:));hold on;p560_2.plot(s1(i,:));hold on;endfor i=1:length(t)p560_1.plot(y1(i,:));hold on;p560_2.plot(f1(i,:));hold onendplot3([0 0],[-1 1],[0.2 0.2])for i=1:length(t)/2p560_1.plot(q2(i,:));hold on;p560_2.plot(s2(i,:));hold on;endfor i=1:length(t)p560_1.plot(y2(i,:));hold on;p560_2.plot(f2(i,:));hold onend]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>Robotic Toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何理解欧拉角中的pitch,roll,yaw]]></title>
    <url>%2FRobotics%2F%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%AC%A7%E6%8B%89%E8%A7%92%E4%B8%AD%E7%9A%84roll%EF%BC%8Cpitch%EF%BC%8Cyaw.html</url>
    <content type="text"><![CDATA[欧拉角也就是绕着固定轴x,y,z旋转 在资料中关于x,y,z和三个角度的方向和对应关系定义的并不是很明确，我认为可能是这个并没有一个严格的规定，但是pitch,roll,yaw三个角度的含义定义还是很明确的。具体定义如下： pitchpitch在英文中的意思是倾斜，坠落的含义，因此就是以翅膀所在的直线为轴发生旋转 rollroll在英文中的意思是翻滚，就是绕着机身所在的那个轴 yawyaw在英文中是yaw是（火箭、飞机、宇宙飞船等）偏航的意思，也就是绕着重力方向为轴旋转]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>机器人学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab机器人工具箱（Robotic Toolbox）]]></title>
    <url>%2FRobotics%2FMatlab%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E5%85%B7%E7%AE%B1.html</url>
    <content type="text"><![CDATA[Matlab机器人工具箱是我们在学习机器人学时候的一个非常好的工具，不但可以帮助我们计算，也可以做图形化的输出。 在此就不多谈安装问题，主要介绍各个函数的使用方法。 启动机器人工具箱1startup_rvc; 绕xyz轴的旋转变化矩阵1234rotx(30*pi/180) %用弧度rotx(30,'deg') %用角度roty(30,'deg')rotz(30,'deg') 绕xyz轴旋转的齐次变换矩阵1234trotx(30*pi/180) %用弧度trotx(30,'deg') %用角度troty(30,'deg')trotz(30,'deg') 平移齐次变换矩阵1transl([10,20,30]) 旋转变换的连续乘积1trotx(30,'deg')*troty(30,'deg')*trotz(30,'deg') rpy角旋转矩阵1234roll=10*pi/180; pitch=20*pi/180; yaw=30*pi/180;rpy2r(roll,pitch,yaw)rpy2r(roll,pitch,yaw,'zyx')rpy2r(roll,pitch,yaw,'xyz') 需要说名的是，rpy2r这个函数在不同的工具箱版本的函数并不一样，使用的角度顺序发生了改变，具体内容可以看具体版本的rpy2r.m文件。 在此附上机器人工具箱中关于各个参数option的定义，仅提供10版本 12345678910111213141516171819202122232425262728293031323334switch opt.order case &#123;'xyz', 'arm'&#125; % XYZ order if numrows(roll) == 1 R = rotx(yaw) * roty(pitch) * rotz(roll); else R = zeros(3,3,numrows(roll)); for i=1:numrows(roll) R(:,:,i) = rotx(yaw(i)) * roty(pitch(i)) * rotz(roll(i)); end end case &#123;'zyx', 'vehicle'&#125; % ZYX order if numrows(roll) == 1 R = rotz(yaw) * roty(pitch) * rotx(roll); else R = zeros(3,3,numrows(roll)); for i=1:numrows(roll) R(:,:,i) = rotz(yaw(i)) * roty(pitch(i)) * rotx(roll(i)); end end case &#123;'yxz', 'camera'&#125; % YXZ order if numrows(roll) == 1 R = roty(yaw) * rotx(pitch) * rotz(roll); else R = zeros(3,3,numrows(roll)); for i=1:numrows(roll) R(:,:,i) = roty(yaw(i)) * rotx(pitch(i)) * rotz(roll(i)); end end endend 检验1234rotx(yaw)*roty(pitch)*rotz(roll)rotz(roll)*roty(pitch)*rotx(yaw)rotx(roll)*roty(pitch)*rotz(yaw)rotz(yaw)*roty(pitch)*rotx(roll) 结果123456%以下二者结果相同rpy2r(roll,pitch,yaw,'zyx')rotz(yaw)*roty(pitch)*rotx(roll)%以下二者结果相同rpy2r(roll,pitch,yaw,'xyz')rotx(yaw)*roty(pitch)*rotz(roll) 个人认为没必要背下来，也没必要理解，只要想用的时候能知道它是怎么算的就好。 Euler角12345%Euler角 旋转矩阵alpha=10*pi/180; beta=20*pi/180; gama=30*pi/180;eul2r(alpha,beta,gama)%检验rotz(alpha)*roty(beta)*rotz(gama) 齐次变换函数homtrans12345V=[30,40,60];T=trotx(30*pi/180);V=[V';1];homtrans(T,V)%检验T*V 绕任意轴旋转函数123%绕任意轴旋转函数theta=30*pi/180; k=[1;0;0];angvec2r(theta,k) 建立连杆坐标系123456789101112L(1)=Link('revolute','a',0,'alpha',0,'d',0);L(1).mdh=1;L(2)=Link('revolute','a',10,'alpha',pi/2,'d',0);L(2).mdh=1;L(3)=Link('revolute','a',6,'alpha',0,'d',0);L(3).mdh=1;R=SerialLink(L,'name','3RRR')%改变一些参数R.base=transl([-10 0 0]);R.tool=transl([4 0 0]);q0=[0 0 0];R.plot(q0) 让连杆坐标系运动起来1234567891011121314L(1)=Link('revolute','a',0,'alpha',0,'d',0);L(1).mdh=1;L(2)=Link('revolute','a',10,'alpha',pi/2,'d',0);L(2).mdh=1;L(3)=Link('revolute','a',6,'alpha',0,'d',0);L(3).mdh=1;R=SerialLink(L,'name','3RRR')q1=linspace(0,pi/2,100)';q2=linspace(0,pi/2,100)';q3=linspace(0,pi/2,100)';Q=[q1,q2,q3];figure(2)R.plot(Q)R.fkine(Q(end,:)) 实操任务 建立两个机器人，机器人基座的相对位置可调。（实际环境中，机器人位置可能发生变动，需要进行修改） 建立一个一条线段（一系列散点），线段的位置可调。（此线段即为机器人末端需要走的xyz轨迹点。实际环境中，轨迹位置随着工件安装位置而变换） 针对线段上的任意一个点，使某一机器人末端以某种姿态到达该点。（为xyz轨迹点加上姿态，一般的，机械臂末端z轴应当和工件表面垂直。这里只有一条线段，可指定rpy为pi/4,0,0) 针对线段上的任意一个点，使某一机器人末端以某种姿态，到达距离该点z向（末端坐标系下的z向）距离为某值的点。(此处表达的是待加工平板有一定厚度，而线段位于平板中部的情况。) 在4的基础上，使得两个机器人末端z 向正对（xy不作要求），且两个机器人末端距离可调b Matlab仿真结果图 使用的机器人工具箱版本为10.3.1版本 修改了工具箱自带的函数mdl_puma560，要使用代码需要在函数开头加上function p560 = mdl_puma560，结尾加上end以实现调用功能。 代码123456789101112131415161718192021222324252627282930313233343536close allclear;d = 0.1;plot3([0 0],[-1 1],[0 0])p560_1 = mdl_puma560;p560_1.name = 'puma1';p560_1.base = [-0.6 0 0];p560_2 = mdl_puma560;p560_2.name = 'puma2';p560_2.base = [0.6 0 0];t=0:0.05:2;%计算puma1机械臂移动到指定点，并将z轴指向朝下的齐次变换矩阵T1 = transl(-0.4,0.2,0.1);T2 = transl(0,-0.4,d)*trotx(180);%计算puma2机械臂移动到指定点，z轴指向朝上的齐次变换矩阵T3 = transl(0.2,-0.2,-0.1);T4 = transl(0,-0.4,-d);%利用jtraj函数让两个机械臂运动到指定点q=p560_1.jtraj(T1,T2,t);s=p560_2.jtraj(T3,T4,t);%移动到指定点后沿直线移动T5 = transl(0,0.5,d)*trotx(180);%puma1沿直线移动T6 = transl(0,0.5,-d);%puma2沿直线移动 m=ctraj(T2,T5,50);n=ctraj(T4,T6,length(t));y=p560_1.ikine6s(m);f=p560_2.ikine6s(n);%画图p560_1.plot(q);hold on;p560_2.plot(s);hold on;p560_1.plot(y);hold on;p560_2.plot(f);hold on;]]></content>
      <categories>
        <category>机器人学</category>
      </categories>
      <tags>
        <tag>Robotic Toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020美赛有感]]></title>
    <url>%2FOtherArticle%2F2020%E7%BE%8E%E8%B5%9B%E6%9C%89%E6%84%9F.html</url>
    <content type="text"><![CDATA[为了出国，提升背景为目的，我在大三报名了美赛，机缘巧合在一个留学交流群里，看到一个同学问有没有人有参加数模美赛的意向，要求是会写代码，我想着就去问问，毕竟我一个从小对数学无感，并且考了几次托福都上不了90的垃圾来说，除了写写代码还能干点什么呢？我就去说明了下自己的情况，他们考虑后也同意了，他们两个是同学，都是在经济学院，男生数学好，微积分什么的都接近满分，女生英语好，托福首考105，我了解到他们的情况之后压力还是很大的，毕竟我也只是一个懂$Matlab$语法的小白啊，数学建模这个词在我的印象里简直就像是“量子力学”一样的神秘（滑稽）。后来我们三个见面聊了聊，互相了解了下情况，我们都没有太多的数学建模基础，情况类似，之后也就没再多聊。 直到考试前，我们关于建模的事情聊得都不多，感觉我们三个都是比较内敛的人，我还算是其中比较外向的了，很多时候如果我不说话，估计群里就不会有人说话了。赶在寒假前期末考试后，我打算好好准备一下，虽然感觉毫无头绪，不知道从哪个高深的算法开始学起，但还是硬着头皮上，买了个课，每天听一听，后来就去北京学GRE了，数模什么的也就暂且搁置了，直到比赛前几周，才继续学一些知识。忘记说了，今年比较特殊的是，受疫情影响，美赛从一次改成了两次，一次是2月份，一次是3月份，我们当时想着或许3月能开学，就去搞3月的比赛（我实际上是觉得自己啥也不会，能拖几天是几天，拖，就恩拖） 然而躲得过初一却躲不过十五，3月份的比赛马上就到了，我们采用的是腾讯会议的方式线上交流。第一天早上起得很早，六点多就看赛题了，没记错的话，我3点多就醒了一次，估计是没准备太紧张了吧…拿到赛题，用词典把B题翻译了下，了解了题意，大概就是问想在海边建沙堡的话，怎么剪最好，我当时看了就觉得，这不就是开脑洞胡思乱想嘛，一个从小都没怎么去过海边的中国人，沙堡？别搞笑了，你问我怎么做汉堡好吃还差不多。 但当我用翻译软件把B题翻译了之后我才发现，或许B题是唯一一个我能理解的题目了，这就像是养龙，你说咋养就咋养，你说怎么搭沙堡就怎么搭，没有硬性规定，全靠你自己的理解，这种还算好的，毕竟只要说服了自己，就觉得没问题不是。在和两个队友商量后，也一致认为B题比较好理解，虽然暂时没有太明确的思路，但至少能靠脑子想想，编，就恩编。第一天，我们最开始思路很乱，没搞清楚应该从哪个点入手，毕竟对一个沙堡要分析的东西还是很多的，没有限定条件随便扯总不是一个事，搞数学的同学想从含水量的角度出发，我想从力的角度考虑，但奈何我的流体力学也只是学了一个皮毛，现在一个公式都想不起来的我，想从力学出发未免太难了点，搞数学的同学倒是想出了个思路，还写了不少式子，到了下午，搞数学的同学竟然已经写出了一个模型，虽然忽略了很多因素，但听起来觉得很有道理，达到了“自圆其说”的作用，于是我们就照着这个方向继续研究，提出问题，否决问题，提出方案，改正方案…就这样我慢慢觉得这个模型有搞头，至少我开始有了点思路。当晚搞数学的同学给我提出了一个难题，让我求一个函数的最小值，单求最小值不要紧，毕竟我还是上了点网课的，懂一点算法，但这函数也太复杂了，迭代套迭代，简直就是一个套娃，我完全没有思路。当晚我们还说明天要不要讨论一下F题，毕竟如果这个式子不能解决，可能这个思路就没法继续下去了。实在不行，我们就去做文字建模。。。 那晚我也没怎么睡好，因为我真的不知道这个“套娃”怎么解决，第二天早上起来我就自学了下可能能解决的办法–蒙特卡洛模拟，试着化简一下式子，再写写代码，听着两个队友在腾讯会议里讨论F题的题意，我得到了一个看起来“不错”的结果，我就在里面和他们说，如果我得到了第二问的结果，你们是觉得做F题还是B题？在我的语言诱导下，我们又开始脑洞大开建沙堡。可能是算出了个结果，有了信心，我们逐渐攻克各个难题，一起讨论，我认为我们仨合作还是很愉快的，总之就是在自圆其说的道路上越走越远233。 我们每天也不熬夜，大概10点左右就收工，早上八点集合，第三天，大部分问题也都已经想好。最后一天，该算的也算完了，我就给自己找点事做，下了个Latex（真的是作死），最后一天把我搞得死去活来，硬是坐在电脑前一天，从零入门Latex还好我有点Markdown基础，搞这个上手也比较快，我们改了又改，填了又填，最后在后半夜两点，在我们三个人一同的见证下交上了论文，4天的美赛到此结束，圆满收工。 这次美赛，收获很多，首先感谢我的两个队友，都很靠谱！我自己也算尽心尽力了，虽然基础差，但在这几天现学了不少东西，总之还是那句话，“尽吾志也而不能至者，可以无悔矣。”]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Diary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】外部中断实验]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C.html</url>
    <content type="text"><![CDATA[外部中断概述 STM32的每个IO都可以作为外部中断输入。 STM32的中断控制器支持19个外部中断/事件请求： 线0~15：对应外部IO口的输入中断。 线16：连接到PVD输出。 线17：连接到RTC闹钟事件。 线18：连接到USB唤醒事件。 每个外部中断线可以独立的配置触发方式（上升沿，下降沿或者双边沿触发），触发/屏蔽，专用的状态位。 从上面可以看出，STM32供IO使用的中断线只有16个，但是STM32F10x系列的IO口多达上百个，那么中断线怎么跟io口对应呢？ GPIOx.0映射到EXTI0 GPIOx.1映射到EXTI1 … GPIOx.15映射到EXTI15 IO口外部中断在中断向量表中只分配了7个中断向量，也就是只能使用7个中断服务函数 从表中可以看出，外部中断线59分配一个中断向量，共用一个服务函数，外部中断线1015分配一个中断向量，共用一个中断服务函数。 外部中断常用库函数1234567891011121314//exti.c文件void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);//设置IO口与中断线的映射关系exp: GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource2);void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct); //初始化中断线：触发方式等ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);//判断中断线中断状态，是否发生void EXTI_ClearITPendingBit(uint32_t EXTI_Line);//清除中断线上的中断标志位 实际代码12345678910111213141516171819202122232425262728293031323334353637383940#include "exti.h"#include "stm32f10x.h"#include "key.h"#include "delay.h"#include "led.h"void EXTIX_Init(void)&#123; EXTI_InitTypeDef EXTI_InitStruct; NVIC_InitTypeDef NVIC_InitStruct; KEY_Init(); RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE); GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource4); EXTI_InitStruct.EXTI_Line = EXTI_Line4; EXTI_InitStruct.EXTI_LineCmd = ENABLE; EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt; EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling; EXTI_Init(&amp;EXTI_InitStruct); NVIC_InitStruct.NVIC_IRQChannel = EXTI4_IRQn; NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE; NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 2; NVIC_InitStruct.NVIC_IRQChannelSubPriority = 2; NVIC_Init(&amp;NVIC_InitStruct);&#125;void EXTI4_IRQHandler(void)&#123; delay_ms(10); if(KEY0 == 0)&#123; LED0 = !LED0; LED1 = !LED1; &#125; //手动清除中断标志位 EXTI_ClearITPendingBit(EXTI_Line4);&#125; 1234567891011121314151617181920212223//main.c文件#include "stm32f10x.h"#include "led.h"#include "beep.h"#include "key.h"#include "sys.h"#include "delay.h"#include "exti.h"#include "usart.h"int main()&#123; delay_init(); //延时函数初始化 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 EXTIX_Init(); LED0 = 0; //先点亮红灯 while(1) &#123; printf("OK\r\n"); &#125; &#125;]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】串口通信基本原理]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[处理器与外部设备通信的两种方式 并行通信 传输原理：数据各个位同时传输。 优点：速度快 缺点：占用引脚资源多 串行通信 传输原理：数据按位顺序传输。 优点：占用引脚资源少 缺点：速度相对较慢 串行通信分类按照数据传送方向，分为： 单工：数据传输只支持数据在一个方向上传输 半双工：允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信； 全双工：允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。 串行通信的通信方式 同步通信：带时钟同步信号传输。-SPI，IIC通信接口 异步通信：不带时钟同步信号。-UART(通用异步收发器),单总线（必须约定波特率，按照相同的速度发送和读取） 常见的串行通信接口 STM32的串口通信接口 UART:通用异步收发器 USART:通用同步异步收发器 大容量STM32F10x系列芯片，包含3个USART和2个UART UART异步通信方式引脚连接方法 RXD:数据输入引脚。数据接受。 TXD:数据发送引脚。数据发送。 UART异步通信方式特点 全双工异步通信。 分数波特率发生器系统，提供精确的波特率。 发送和接受共用的可编程波特率，最高可达4.5Mbits/s 可编程的数据字长度（8位或者9位）； 可配置的停止位（支持1或者2位停止位）； 可配置的使用DMA多缓冲器通信。 单独的发送器和接收器使能位。 检测标志：① 接受缓冲器 ②发送缓冲器空 ③传输结束标志 多个带标志的中断源。触发中断。 其他：校验控制，四个错误检测标志。 STM32串口异步通信需要定义的参数 起始位，通信双方约定从空闲位开始 数据位（8位或者9位），第九位就是奇偶校验位 奇偶校验位（第9位），偶校验：使1的数量为偶数；奇校验：使1的数量为奇数 停止位（1,15,2位） 波特率设置 常用的串口相关寄存器 USART_SR状态寄存器 USART_DR数据寄存器 USART_BRR波特率寄存器 波特率计算方法 串口操作相关库函数1234567891011void USART_Init(); //串口初始化：波特率，数据字长，奇偶校验，硬件流控以及收发使能void USART_Cmd();//使能串口void USART_ITConfig();//使能相关中断void USART_SendData();//发送数据到串口，DRuint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据FlagStatus USART_GetFlagStatus();//获取状态标志位void USART_ClearFlag();//清除状态标志位ITStatus USART_GetITStatus();//获取中断状态标志位void USART_ClearITPendingBit();//清除中断状态标志位 串口配置的一般步骤 串口时钟使能，GPIO时钟使能:RCC_APB2PeriphClockCmd(); 串口复位:USART_DeInit(); 这一步不是必须的 GPIO端口模式设置:GPIO_Init(); 模式设置为GPIO_Mode_AF_PP 串口参数初始化：USART_Init(); 开启中断并且初始化NVIC（如果需要开启中断才需要这个步骤）NVIC_Init();``USART_ITConfig(); 使能串口:USART_Cmd(); 编写中断处理函数：USARTx_IRQHandler(); 串口数据收发：void USART_SendData();//发送数据到串口，DR, uint16_t USART_ReceiveData();//接受数据，从DR读取接受到的数据 串口传输状态获取：FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG); void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】NVIC中断优先级管理]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91NVIC%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[NVIC中断介绍 CM3内核支持256个中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。 STM32并没有使用CM3内核的全部东西，而是只用了它的一部分。 STM32有84个中断，包括16个内核中断和68个可屏蔽中断，具有16级可编程的中断优先级。 STM32F103系列上面，又只有60个可屏蔽中断（在107系列才有68个） 中断管理方法首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。 分组配置是在寄存器SCB-&gt;AIRCR中配置： 抢占优先级 &amp; 响应优先级区别 高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。 抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。 抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。 如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行； 举例假定设置中断优先级组为2，然后设置中断3(RTC中断)的抢占优先级为2，响应优先级为1。 中断6（外部中断0）的抢占优先级为3，响应优先级为0。中断7（外部中断1）的抢占优先级为2，响应优先级为0。 那么这3个中断的优先级顺序为：中断7&gt;中断3&gt;中断6。 特别说明一般情况下，系统代码执行过程中，只设置一次中断优先级分组，比如分组2，设置好分组之后一般不会再改变分组。随意改变分组会导致中断管理混乱，程序出现意想不到的执行结果。 中断优先级分组函数1234567void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)&#123; assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup)); SCB-&gt;AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;&#125;//比如：NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 中断设置相关寄存器123456__IO uint8_t IP[240]; //中断优先级控制的寄存器组__IO uint32_t ISER[8]; //中断使能寄存器组__IO uint32_t ICER[8]; //中断失能寄存器组__IO uint32_t ISPR[8]; //中断挂起寄存器组__IO uint32_t ICPR[8]; //中断解挂寄存器组__IO uint32_t IABR[8]; //中断激活标志位寄存器组 MDK中NVIC寄存器结构体12345678910111213141516typedef struct&#123; __IO uint32_t ISER[8]; uint32_t RESERVED0[24]; __IO uint32_t ICER[8]; uint32_t RSERVED1[24]; __IO uint32_t ISPR[8]; uint32_t RESERVED2[24]; __IO uint32_t ICPR[8]; uint32_t RESERVED3[24]; __IO uint32_t IABR[8]; uint32_t RESERVED4[56]; __IO uint8_t IP[240]; uint32_t RESERVED5[644]; __O uint32_t STIR; &#125; NVIC_Type; 对于每个中断怎么设置优先级中断优先级控制的寄存器组：IP[240] 全称是：Interrupt Priority Registers 240个8位寄存器，每个中断使用一个寄存器来确定优先级。STM32F10x系列一共60个可屏蔽中断，使用IP[59]~IP[0]。 每个IP寄存器的高4位用来设置抢占和响应优先级（根据分组），低4位没有用到。 void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct); 中断使能寄存器组：ISER[8] 作用：用来使能中断 32位寄存器，每个位控制一个中断的使能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ISER[0]和ISER[1]。 ISER[0]的bit0-bit31分别对应中断0-31。ISER[1]的bit0-27对应中断32~59； void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct); 中断失能寄存器组：ICER[8] 作用：只读，通过它可以知道当前在执行的中断是哪一个 32位寄存器，每个位控制一个中断的失能。STM32F10x只有60个可屏蔽中断，所以只使用了其中的ICER[0]和ICER[1]。 ICER[0]的bit0~bit31分别对应中断0~31。ICER[1]的bit0~27对应中断32~59； 配置方法跟ISER一样static __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn) 中断挂起控制寄存器组：ISPR[8] 作用：用来挂起中断 中断解挂控制寄存器组：ICPR[8] 作用：用来解挂中断 123static __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)；static __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)；static __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn) 中断激活标志位寄存器组：IABR [8] 作用：只读，通过它可以知道当前在执行的中断是哪一个 如果对应位为1，说明该中断正在执行。 static __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn) 中断参数初始化函数12345678910111213141516void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);typedef struct&#123; uint8_t NVIC_IRQChannel; //设置中断通道 uint8_t NVIC_IRQChannelPreemptionPriority;//设置响应优先级 uint8_t NVIC_IRQChannelSubPriority; //设置抢占优先级 FunctionalState NVIC_IRQChannelCmd; //使能/使能&#125; NVIC_InitTypeDef;NVIC_InitTypeDef NVIC_InitStructure;NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;// 抢占优先级为1NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;// 子优先级位2NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//IRQ通道使能NVIC_Init(&amp;NVIC_InitStructure); //根据上面指定的参数初始化NVIC寄存器 中断优先级设置步骤 系统运行后先设置中断优先级分组。调用函数：void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);整个系统执行过程中，只设置一次中断分组。 针对每个中断，设置对应的抢占优先级和响应优先级：void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct); 如果需要挂起/解挂，查看中断当前激活状态，分别调用相关函数即可。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】端口复用]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91%E7%AB%AF%E5%8F%A3%E5%A4%8D%E7%94%A8.html</url>
    <content type="text"><![CDATA[什么是端口复用STM32有很多的内置外设，这些外设的外部引脚都是与GPIO复用的。也就是说，一个GPIO如果可以复用为内置外设的功能引脚，那么当这个GPIO作为内置外设使用的时候，就叫做复用。 例如串口1 的发送接收引脚是PA9,PA10，当我们把PA9,PA10不用作GPIO，而用做复用功能串口1的发送接收引脚的时候，叫端口复用。 端口复用配置过程以PA9,PA10配置为串口1为例 GPIO端口时钟使能。RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 复用外设时钟使能。比如你要将端口PA9,PA10复用为串口，所以要使能串口时钟。RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE); 端口模式配置。 GPIO_Init（）函数。查表：《STM32中文参考手册V10》P110的表格“8.1.11外设的GPIO配置” 12345678910111213RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//①IO时钟使能RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);//②外设时钟使能//③初始化IO为对应的模式GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9//复用推挽输出GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 PA.10 浮空输入GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入GPIO_Init(GPIOA, &amp;GPIO_InitStructure);]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】SysTick定时器]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91SysTick%E5%AE%9A%E6%97%B6%E5%99%A8.html</url>
    <content type="text"><![CDATA[Systick定时器是什么 Systick定时器，是一个简单的定时器，对于CM3,CM4内核芯片，都有Systick定时器。 Systick定时器常用来做延时，或者实时系统的心跳时钟。这样可以节省MCU资源，不用浪费一个定时器。比如UCOS中，分时复用，需要一个最小的时间戳，一般在STM32+UCOS系统中，都采用Systick做UCOS心跳时钟。 Systick定时器就是系统滴答定时器，一个24 位的倒计数定时器，计到0 时，将从RELOAD 寄存器中自动重装载定时初值。只要不把它在SysTick 控制及状态寄存器中的使能位清除，就永不停息，即使在睡眠模式下也能工作。 SysTick定时器被捆绑在NVIC中，用于产生SYSTICK异常（异常号：15） Systick中断的优先级也可以设置。 Systick相关寄存器 CTRL SysTick 控制和状态寄存器 LOAD SysTick 自动重装载除值寄存器对于STM32，外部时钟源是 HCLK(AHB总线时钟）的1/8内核时钟是 HCLK时钟,配置函数：SysTick_CLKSourceConfig() VAL SysTick 当前值寄存器 CALIB SysTick 校准值寄存器 Systick库函数固件库中的Systick相关函数： 1234567SysTick_CLKSourceConfig() //Systick时钟源选择 misc.c文件中SysTick_Config(uint32_t ticks) //初始化systick,时钟为HCLK,并开启中断//core_cm3.h/core_cm4.h文件中//Systick中断服务函数：void SysTick_Handler(void); 123456789101112131415//SysTick_CLKSourceConfig函数void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)&#123; /* Check the parameters */ assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource)); if (SysTick_CLKSource == SysTick_CLKSource_HCLK) &#123; SysTick-&gt;CTRL |= SysTick_CLKSource_HCLK; &#125; else &#123; SysTick-&gt;CTRL &amp;= SysTick_CLKSource_HCLK_Div8; &#125;&#125; 123456789101112131415//SysTick_CLKSourceConfig函数static __INLINE uint32_t SysTick_Config(uint32_t ticks)&#123; if (ticks &gt; SysTick_LOAD_RELOAD_Msk) return (1); /* Reload value impossible */ /* set reload register */ SysTick-&gt;LOAD = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1; /* set Priority for Cortex-M0 System Interrupts */ NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1); SysTick-&gt;VAL = 0; /* Load the SysTick Counter Value */ SysTick-&gt;CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk; /* Enable SysTick IRQ and SysTick Timer */ return (0); /* Function successful */&#125; 12345678910111213141516171819202122232425//用中断的方式实现delay延时static __IO uint32_t TimingDelay;void Delay(__IO uint32_t nTime)&#123; TimingDelay = nTime; while(TimingDelay != 0);&#125;void SysTick_Handler(void)&#123; if (TimingDelay != 0x00) &#123; TimingDelay--; &#125;&#125; int main(void) &#123; … if (SysTick_Config(SystemCoreClock / 1000)) //systick时钟为HCLK，中断时间间隔1ms &#123; while (1); &#125; while(1) &#123; Delay(200);//2ms … &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void delay_init()&#123;#if SYSTEM_SUPPORT_OS //如果需要支持OS. u32 reload;#endif SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); //选择外部时钟 HCLK/8 fac_us=SystemCoreClock/8000000; //为系统时钟的1/8 #if SYSTEM_SUPPORT_OS //如果需要支持OS. reload=SystemCoreClock/8000000; //每秒钟的计数次数 单位为K reload*=1000000/delay_ostickspersec; //根据delay_ostickspersec设定溢出时间 //reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右 fac_ms=1000/delay_ostickspersec; //代表OS可以延时的最少单位 SysTick-&gt;CTRL|=SysTick_CTRL_TICKINT_Msk; //开启SYSTICK中断 SysTick-&gt;LOAD=reload; //每1/delay_ostickspersec秒中断一次 SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk; //开启SYSTICK #else fac_ms=(u16)fac_us*1000; //非OS下,代表每个ms需要的systick时钟数 #endif&#125; #if SYSTEM_SUPPORT_OS //如果需要支持OS.//延时nus//nus为要延时的us数. void delay_us(u32 nus)&#123; u32 ticks; u32 told,tnow,tcnt=0; u32 reload=SysTick-&gt;LOAD; //LOAD的值 ticks=nus*fac_us; //需要的节拍数 tcnt=0; delay_osschedlock(); //阻止OS调度，防止打断us延时 told=SysTick-&gt;VAL; //刚进入时的计数器值 while(1) &#123; tnow=SysTick-&gt;VAL; if(tnow!=told) &#123; if(tnow&lt;told)tcnt+=told-tnow; //这里注意一下SYSTICK是一个递减的计数器就可以了. else tcnt+=reload-tnow+told; told=tnow; if(tcnt&gt;=ticks)break; //时间超过/等于要延迟的时间,则退出. &#125; &#125;; delay_osschedunlock(); //恢复OS调度 &#125;//延时nms//nms:要延时的ms数void delay_ms(u16 nms)&#123; if(delay_osrunning&amp;&amp;delay_osintnesting==0) //如果OS已经在跑了,并且不是在中断里面(中断里面不能任务调度) &#123; if(nms&gt;=fac_ms) //延时的时间大于OS的最少时间周期 &#123; delay_ostimedly(nms/fac_ms); //OS延时 &#125; nms%=fac_ms; //OS已经无法提供这么小的延时了,采用普通方式延时 &#125; delay_us((u32)(nms*1000)); //普通方式延时 &#125;#else //不用OS时//延时nus//nus为要延时的us数. void delay_us(u32 nus)&#123; u32 temp; SysTick-&gt;LOAD=nus*fac_us; //时间加载 SysTick-&gt;VAL=0x00; //清空计数器 SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ; //开始倒数 do &#123; temp=SysTick-&gt;CTRL; &#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //等待时间到达 SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器 &#125;//延时nms//注意nms的范围//SysTick-&gt;LOAD为24位寄存器,所以,最大延时为://nms&lt;=0xffffff*8*1000/SYSCLK//SYSCLK单位为Hz,nms单位为ms//对72M条件下,nms&lt;=1864 void delay_ms(u16 nms)&#123; u32 temp; SysTick-&gt;LOAD=(u32)nms*fac_ms; //时间加载(SysTick-&gt;LOAD为24bit) SysTick-&gt;VAL =0x00; //清空计数器 SysTick-&gt;CTRL|=SysTick_CTRL_ENABLE_Msk ; //开始倒数 do &#123; temp=SysTick-&gt;CTRL; &#125;while((temp&amp;0x01)&amp;&amp;!(temp&amp;(1&lt;&lt;16))); //等待时间到达 SysTick-&gt;CTRL&amp;=~SysTick_CTRL_ENABLE_Msk; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器 &#125; #endif]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】STM32时钟系统和时钟系统初始化函数]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91STM32%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F.html</url>
    <content type="text"><![CDATA[时钟系统知识总结 STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。 HSI是高速内部时钟，RC振荡器，频率为8MHz，精度不高。 HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~16MHz。 LSI是低速内部时钟，RC振荡器，频率为40kHz，提供低功耗时钟。WDG LSE是低速外部时钟，接频率为32.768kHz的石英晶体。RTC PLL为锁相环倍频输出，其时钟输入源可选择为HSI/2、HSE或者HSE/2倍频可选择为2~16倍，但是其输出频率最大不得超过72MHz。 系统时钟SYSCLK可来源于三个时钟源： HSI振荡器时钟 HSE振荡器时钟 PLL时钟 STM32可以选择一个时钟信号输出到MCO脚(PA8)上，可以选择为PLL输出的2分频、HSI、HSE、或者系统时钟。 任何一个外设在使用之前，必须首先使能其相应的时钟。 几个重要的时钟： SYSCLK(系统时钟) : AHB总线时钟 APB1总线时钟(低速): 速度最高36MHz APB2总线时钟(高速): 速度最高72MHz PLL时钟 RCC相关配置寄存器12345678910111213typedef struct&#123; __IO uint32_t CR; //HSI,HSE,CSS,PLL等的使能和就绪标志位 __IO uint32_t CFGR; //PLL等的时钟源选择，分频系数设定 __IO uint32_t CIR; // 清除/使能 时钟就绪中断 __IO uint32_t APB2RSTR; //APB2线上外设复位寄存器 __IO uint32_t APB1RSTR; //APB1线上外设复位寄存器 __IO uint32_t AHBENR; //DMA，SDIO等时钟使能 __IO uint32_t APB2ENR; //APB2线上外设时钟使能 __IO uint32_t APB1ENR; //APB1线上外设时钟使能 __IO uint32_t BDCR; //备份域控制寄存器 __IO uint32_t CSR; //控制状态寄存器&#125; RCC_TypeDef; SystemInit源代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273void SystemInit (void)&#123; /* Reset the RCC clock configuration to the default reset state(for debug purpose) */ /* Set HSION bit */ RCC-&gt;CR |= (uint32_t)0x00000001; //或等于，也就是将最低位设置为1，其它位不变 //将最低位设置为1，HSION：内部高速时钟使能 /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */#ifndef STM32F10X_CL RCC-&gt;CFGR &amp;= (uint32_t)0xF8FF0000; //并未定义STM32F10X_CL#else RCC-&gt;CFGR &amp;= (uint32_t)0xF0FF0000; //将0-15位置零，将24-27置零 //查表可知，低四位为零目的是使SW, HPRE, PPRE1, PPRE2, ADCPRE, MCO几个寄存器复位。#endif /* STM32F10X_CL */ /* Reset HSEON, CSSON and PLLON bits */ RCC-&gt;CR &amp;= (uint32_t)0xFEF6FFFF; //将16-19位与0110运算，也就是16,19位置零 //将24-27位与1110运算，也就是24位置零 //查表可知，目的是将HSEON, CSSON and PLLON几个寄存器复位 /* Reset HSEBYP bit */ RCC-&gt;CR &amp;= (uint32_t)0xFFFBFFFF; //16-19位为B，也就是1011 //与运算，也就是将18位置零 //查表可知，目的是将HSEBYP复位 /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */ RCC-&gt;CFGR &amp;= (uint32_t)0xFF80FFFF; //16-19位为与运算0000 //20-23位为与运算1000 //也就是将16-19位置零，20-23位置零 //查表可知，目的是将PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE 复位#ifdef STM32F10X_CL //并未定义 /* Reset PLL2ON and PLL3ON bits */ RCC-&gt;CR &amp;= (uint32_t)0xEBFFFFFF; /* Disable all interrupts and clear pending bits */ RCC-&gt;CIR = 0x00FF0000; /* Reset CFGR2 register */ RCC-&gt;CFGR2 = 0x00000000;#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL) /* Disable all interrupts and clear pending bits */ RCC-&gt;CIR = 0x009F0000; /* Reset CFGR2 register */ RCC-&gt;CFGR2 = 0x00000000; #else /* Disable all interrupts and clear pending bits */ RCC-&gt;CIR = 0x009F0000;#endif /* STM32F10X_CL */ #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL) //定义了STM32F10X_HD #ifdef DATA_IN_ExtSRAM SystemInit_ExtMemCtl(); #endif /* DATA_IN_ExtSRAM */#endif /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */ /* Configure the Flash Latency cycles and enable prefetch buffer */ SetSysClock();#ifdef VECT_TAB_SRAM SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */#else SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */#endif &#125; 12345678910111213141516static void SetSysClock(void)&#123;#ifdef SYSCLK_FREQ_HSE SetSysClockToHSE();#elif defined SYSCLK_FREQ_24MHz SetSysClockTo24();#elif defined SYSCLK_FREQ_36MHz SetSysClockTo36();#elif defined SYSCLK_FREQ_48MHz SetSysClockTo48();#elif defined SYSCLK_FREQ_56MHz SetSysClockTo56(); #elif defined SYSCLK_FREQ_72MHz SetSysClockTo72();#endif&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495static void SetSysClockTo72(void)&#123; __IO uint32_t StartUpCounter = 0, HSEStatus = 0; /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/ /* Enable HSE */ RCC-&gt;CR |= ((uint32_t)RCC_CR_HSEON); /* Wait till HSE is ready and if Time out is reached exit */ do &#123; HSEStatus = RCC-&gt;CR &amp; RCC_CR_HSERDY; StartUpCounter++; &#125; while((HSEStatus == 0) &amp;&amp; (StartUpCounter != HSE_STARTUP_TIMEOUT)); if ((RCC-&gt;CR &amp; RCC_CR_HSERDY) != RESET) &#123; HSEStatus = (uint32_t)0x01; &#125; else &#123; HSEStatus = (uint32_t)0x00; &#125; if (HSEStatus == (uint32_t)0x01) &#123; /* Enable Prefetch Buffer */ FLASH-&gt;ACR |= FLASH_ACR_PRFTBE; /* Flash 2 wait state */ FLASH-&gt;ACR &amp;= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY); FLASH-&gt;ACR |= (uint32_t)FLASH_ACR_LATENCY_2; /* HCLK = SYSCLK */ RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1; /* PCLK2 = HCLK */ RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1; /* PCLK1 = HCLK */ RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;#ifdef STM32F10X_CL /* Configure PLLs ------------------------------------------------------*/ /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */ /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */ RCC-&gt;CFGR2 &amp;= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL | RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC); RCC-&gt;CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 | RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5); /* Enable PLL2 */ RCC-&gt;CR |= RCC_CR_PLL2ON; /* Wait till PLL2 is ready */ while((RCC-&gt;CR &amp; RCC_CR_PLL2RDY) == 0) &#123; &#125; /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ RCC-&gt;CFGR &amp;= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL); RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLMULL9); #else /* PLL configuration: PLLCLK = HSE * 9 = 72 MHz */ RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL)); RCC-&gt;CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);#endif /* STM32F10X_CL */ /* Enable PLL */ RCC-&gt;CR |= RCC_CR_PLLON; /* Wait till PLL is ready */ while((RCC-&gt;CR &amp; RCC_CR_PLLRDY) == 0) &#123; &#125; /* Select PLL as system clock source */ RCC-&gt;CFGR &amp;= (uint32_t)((uint32_t)~(RCC_CFGR_SW)); RCC-&gt;CFGR |= (uint32_t)RCC_CFGR_SW_PLL; /* Wait till PLL is used as system clock source */ while ((RCC-&gt;CFGR &amp; (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08) &#123; &#125; &#125; else &#123; /* If HSE fails to start-up, the application will have wrong clock configuration. User can add here some code to deal with this error */ &#125;&#125;#endif]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】struct和typedef struct]]></title>
    <url>%2FMicroController%2F%E3%80%90C%E3%80%91struct%E5%92%8Ctypedef%20struct.html</url>
    <content type="text"><![CDATA[首先注意在C和C++里不同 在C中定义一个结构体类型要用typedef: 1234typedef struct Student &#123; int a; &#125;Stu; 于是在声明变量的时候就可：Stu stu1 (如果没有typedef就必须用struct Student stu1;来声明) 这里的Stu实际上就是struct Student的别名。Stu==struct Student 另外这里也可以不写Student（于是也不能struct Student stu1;了，必须是Stu stu1;） 1234typedef struct &#123; int a; &#125;Stu; 但在c++里很简单，直接 1234struct Student &#123; int a; &#125;; 于是就定义了结构体类型Student，声明变量时直接Student stu2 其次 在c++中如果用typedef的话，又会造成区别： 1234struct Student&#123; int a;&#125;stu1; //stu1是一个变量 1234typedef struct Student2 &#123; int a; &#125;stu2; //stu2是一个结构体类型=struct Student 使用时可以直接访问stu1.a， 但是stu2则必须先stu2 s2;然后s2.a=10; 最后 typedef struct和struct的区别： 12345678typedef struct tagMyStruct &#123; int iNum; long lLength; &#125; MyStruct;//上面的tagMyStruct是标识符，//MyStruct是变量类型（相当于（int,char等）） 这语句实际上完成两个操作： 定义一个新的结构类型 12345struct tagMyStruct &#123; int iNum; long lLength; &#125;; typedef为这个新的结构起了一个名字，叫MyStruct 1 typedef struct tagMyStruct MyStruct; 12345typedef struct tagMyStruct &#123; int iNum; long lLength; &#125; MyStruct; 在C中，这个申明后申请结构变量的方法有两种： struct tagMyStruct 变量名 MyStruct 变量名 在c++中可以有 struct tagMyStruct 变量名 MyStruct 变量名 tagMyStruct 变量名]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【C】从GPIO_Init引发的关于C的研究]]></title>
    <url>%2FMicroController%2F%E3%80%90C%E3%80%91%E4%BB%8EGPIO_Init%E5%BC%95%E5%8F%91%E7%9A%84%E5%85%B3%E4%BA%8EC%E7%9A%84%E7%A0%94%E7%A9%B6.html</url>
    <content type="text"><![CDATA[在我看下面这段代码对GPIO_Init有一些不理解 123456789101112void BEEP_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; //声明变量 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //不理解 GPIO_ResetBits(GPIOB,GPIO_Pin_8);&#125; 首先看一下GPIO_Init的语法 1void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct); 我产生了几个疑问： GPIO_TypeDef* GPIOx是什么意思？ 为什么&amp;GPIO_InitStructure要用指针类型？ 为什么GPIOB不用使用指针类型？ 1234567//这里定义了一个结构体typedef struct&#123; u16 GPIO_Pin; GPIOSpeed_TypeDef GPIO_Speed; GPIOMode_TypeDef GPIO_Mode;&#125;GPIO_InitTypeDef; //代码里用它来声明变量 怎么理解呢？int 是 类型， i 是变量GPIO_InitTypeDef GPIO_InitStructure;同样，GPIO_InitTypeDef 是类型，GPIO_InitStructure 是变量！ C语言里面没有这种GPIO_InitTypeDef 类型 ，所以要自己 通过 typedef 来定义这种类型。 引用自一个知乎问题，链接 一般int* p表示p类型是一个int型指针，int *p表示p是一个指针，指向的类型是int。 也就是GPIO_TypeDef* GPIOx等同于GPIO_TypeDef *GPIOx，而且我之前对于init *p也有误解，我以为这是在声明一个init常量，我当时误认*已经把地址取值了，实则是造成了误会，它是定义了一个指向init类型的指针变量，也就是p，所以从这点考虑，init* p或许表意更清楚一点！ 终于搞懂了！！！ 第二个问题也就好解释了，因为GPIO_Init就是要求输入两个指针变量 第三个问题 GPIOB本身就是一个指针类型！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】按键输入实验]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E5%AE%9E%E9%AA%8C.html</url>
    <content type="text"><![CDATA[GPIO操作复习 读取IO口输入电平调用库函数为 1uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 读取IO口输入电平操作寄存器为 1GPIOx_IDR:端口输入寄存器 使用位带操作读取IO口输入电平： 12PEin(4) //读取GPIOE.4口电平PEin(n) //读取GPIOE.n口电平 步骤 使能按键对应IO口时钟。调用函数：RCC_APB2PeriphClockCmd() 初始化IO模式：上拉/下拉输入。调用函数：GPIO_Init() 扫描IO口电平（库函数/寄存器/位操作） 硬件连接 所以需要打开PA,PE的时钟，并打开PA0; PE2,3,4; 而且，对于KEY0，一端连接地，另一端连接PE4的IO口，KEY1，KEY2同理，所以当案件按下的时候，IO口坚持得到低电平。WK_UP正好相反。 按键扫描思路扫描的两种类型 支持连续监测，比如遥控器选台的前进按钮，一直按会一直跳台 不支持连续监测，比如遥控器的关机/开机按钮，一直按但只会执行一次操作 引入C语言关键字：static Static申明的局部变量，存储在静态存储区。 它在函数调用结束之后，不会被释放。它的值会一直保留下来。 所以可以说static申明的局部变量，具有记忆功能。 1234567891011121314151617//利用两个函数说明问题//1. 用intint getValue(void)&#123; int flag=0; flag++; return flag;&#125;//2. 用staticint getValue(void)&#123; static int flag=0; /*初始化函数只会在第一次使用中运行，第二次调用getvalue函数就会直接跳到下面的语句，不会再次执行。*/ flag++; return flag;&#125; 实际代码操作尝试！第一次123456789101112131415161718192021222324252627282930/*demo1，将循环体放在两个getvalue中*/#include &lt;stdio.h&gt;int getvalue1(void)&#123; int a; for(int i = 10; i &gt; 0; i--) &#123; int a = 0; a++; return a; &#125;&#125;int getvalue2(void)&#123; for(int i = 10; i &gt; 0; i--)&#123; static int b = 0; b++; return b; &#125;&#125;int main()&#123; int c = getvalue1(); int d = getvalue2(); printf("%d, %d", c, d); getchar(); return 0;&#125; 编译报warning: control reaches end of non-void function 编译结果为“1,1”，结果不对！ 分析原因: C语言必须要有返回值，例如return 0，或者return a等等 我将两个getvalue函数中的return写在了循环体里，并不会返回！ 至于为什么出现了错误的结果，根据debug发现，并没有执行循环，而是只执行了一次，原因在于第一次就return了！ 第二次进行如下修改： 123456789101112131415161718192021222324252627282930//将return修改到循环体之外#include &lt;stdio.h&gt;int getvalue1(void)&#123; for(int i = 10; i &gt; 0; i--) &#123; int a = 0; a++; &#125; return a; &#125;int getvalue2(void)&#123; for(int i = 10; i &gt; 0; i--) &#123; static int b = 0; b++; &#125; return b;&#125;int main()&#123; int c = getvalue1(); int d = getvalue2(); printf("%d, %d", c, d); getchar(); return 0;&#125; 编译出现错误：identifier &quot;a&quot; is undefined；identifier &quot;b&quot; is undefined； 原因：未定义变量a和b！ 我的int a,static int b,都是在循环体里定义的，依然在函数中生效 第三次继续修改！ 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int getvalue1(void)&#123; int a; //添加定义 for(int i = 10; i &gt; 0; i--) &#123; int a = 0; a++; &#125; return a; &#125;int getvalue2(void)&#123; int b; //添加定义 for(int i = 10; i &gt; 0; i--) &#123; static int b = 0; b++; &#125; return b;&#125;int main()&#123; int c = getvalue1(); int d = getvalue2(); printf("%d, %d", c, d); getchar(); return 0;&#125; 编译未出现错误，但结果为“0,1”，结果不对 分析原因：暂时未知，怀疑是循环体执行的`b`并没有并没有返回出来 第四次继续修改！ 12345678910111213141516171819202122232425//将循环体放在main中，而getvalue函数不执行循环功能#include &lt;stdio.h&gt;int getvalue1(void)&#123; int a = 0; a++; return a;&#125;int getvalue2(void)&#123; static int b = 0; b++; return b;&#125;int main()&#123; int c,d; for(int i = 10; i &gt;0; i--)&#123; int c = getvalue1(); int d = getvalue2(); &#125; printf("%d, %d", c, d); getchar(); return 0;&#125; 结果仍然不对…得到的结果为：7349584, 0 原因重复定义？一个变量只能被定义一次！ 一个函数外面对变量进行了定义，循环体里就不用定义了。static可能是个例外… 第五次最终修改版本： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;int getvalue1(void)&#123; int a = 0; a++; return a;&#125;int getvalue2(void)&#123; static int b = 0; b++; return b;&#125;int main()&#123; int a,b; for(int i = 10; i &gt;0; i--)&#123; a = getvalue1(); b = getvalue2(); &#125; printf("%d, %d", a, b); getchar(); return 0;&#125; 结果正确，得到“1,10”!! 总结问题在于C语言基础不牢，关于变量定义范围还需要进行复习！！ 两种扫描的具体思路1234567891011121314//支持连续按//代码比较好理解u8 KEY_Scan(void) &#123; if(KEY按下） &#123; delay_ms(10)；//延时10-20ms，防抖。 if(KEY确实按下) &#123; return KEY_Value； &#125; return 无效值； &#125; &#125; 12345678910111213141516//不支持连续按，按一次就是一次//代码稍显复杂，比较巧妙u8 KEY_Scan(void) &#123; static u8 key_up=1; //引入局部变量key_up if（key_up &amp;&amp; KEY按下） &#123; delay_ms(10); //延时，防抖 key_up=0; //标记这次key已经按下 if(KEY确实按下) &#123; return KEY_VALUE; &#125; &#125;else if(KEY没有按下) key_up=1; return 没有按下 &#125; 1234567891011121314151617//按键扫描二合一！//函数需要给一个值u8 KEY_Scan(u8 mode) &#123; static u8 key_up=1; if(mode==1) key_up=1;//支持连续按 if（key_up &amp;&amp; KEY按下） &#123; delay_ms(10);//延时，防抖 key_up=0;//标记这次key已经按下 if(KEY确实按下) &#123; return KEY_VALUE; &#125; &#125;else if(KEY没有按下) key_up=1; return 没有按下 &#125; 实际代码123456789101112131415161718//key.h#ifndef __KEY_H#define __KEY_H #define KEY0 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_4) //读取按键0#define KEY1 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_3) //读取按键1#define KEY2 GPIO_ReadInputDataBit(GPIOE,GPIO_Pin_2) //读取按键2 #define WK_UP GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)//读取按键3(WK_UP) #define KEY0_PRES 1 //KEY0按下#define KEY1_PRES 2 //KEY1按下#define KEY2_PRES 3 //KEY2按下#define WKUP_PRES 4 //KEY_UP按下(即WK_UP/KEY_UP)void KEY_Init(void); //IO初始化u8 KEY_Scan(u8); //按键扫描函数#endif 1234567891011121314151617181920212223242526272829303132333435363738394041//key.c#include "stm32f10x.h"#include "key.h"#include "delay.h"void KEY_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOE,ENABLE); //使能PORTA,PORTE时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4; //KEY0-KEY2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; //设置成上拉输入 GPIO_Init(GPIOE, &amp;GPIO_InitStructure); //初始化GPIOE2,3,4 //初始化 WK_UP--&gt;GPIOA.0 下拉输入 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0设置成输入，默认下拉 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); //初始化GPIOA.0&#125;//按键处理函数，用来返回按键值//mode:0,不支持连续按;1,支持连续按;//各种返回值代表的情况：//0，没有任何按键按下//1，KEY0按下//2，KEY1按下//3，KEY2按下 //4，KEY3按下 WK_UPu8 KEY_Scan(u8 mode)&#123; static u8 key_up=1;//按键按松开标志 if(mode)key_up=1; //支持连按 if(key_up&amp;&amp;(KEY0==0||KEY1==0||KEY2==0||WK_UP==1)) // if条件句判读是否有按键按下，有则执行判断语句 &#123; delay_ms(10); //去抖动 key_up=0; if(KEY0==0)return KEY0_PRES; else if(KEY1==0)return KEY1_PRES; else if(KEY2==0)return KEY2_PRES; else if(WK_UP==1)return WKUP_PRES; &#125;else if(KEY0==1&amp;&amp;KEY1==1&amp;&amp;KEY2==1&amp;&amp;WK_UP==0)key_up=1; return 0; // 无按键按下&#125; 12345678910111213141516171819202122232425262728293031323334353637383940//main.c#include "stm32f10x.h"#include "led.h"#include "beep.h"#include "key.h"#include "sys.h"#include "delay.h"int main()&#123; u8 key=0; delay_init(); //延时函数初始化 LED_Init(); //LED端口初始化 KEY_Init(); //初始化与按键连接的硬件接口 beep_init(); //初始化蜂鸣器端口 LED0 = 0; //先点亮红灯 while(1) &#123; key = KEY_Scan(0); //得到键值 if(key) &#123; switch(key) &#123; case WKUP_PRES: //控制蜂鸣器 BEEP = !BEEP; //取反，则蜂鸣器不叫 break; case KEY2_PRES: //控制LED0翻转 LED0 = !LED0; break; case KEY1_PRES: //控制LED1翻转 LED1 = !LED1; break; case KEY0_PRES: //同时控制LED0,LED1翻转 LED0 = !LED0; LED1 = !LED1; break; &#125; &#125;else delay_ms(10); &#125; &#125;]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用VSCode写博客]]></title>
    <url>%2FBlog%2F%E4%BD%BF%E7%94%A8VScode%E5%86%99%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[使用原因偶然之间看到一篇文章推荐使用VSCode，对于它我也是早有耳闻，一个开源的代码编辑器，但是之前觉得麻烦，觉得自己已经有了Visual Studio 2017就没必要再下一个代码编辑器了，当时以为VSCode不带有编译功能。 昨晚没事干，就下了个尝试一下啊，果然耳目一新，觉得从颜值也好，使用上也好都很舒服，但在配置的时候也遇到了问题，研究了好久才终于解决，特此记录！ 步骤 从官网安装VSCode 安装MinGW64,并将bin文件添加到Path路径中 安装插件 成功运行代码！ 具体过程从官网安装VSCode过程比较简单，从Google搜索VSCode进入官方网站，下载Windows的版本，运行即可。 安装MinGW64由于想在VSCode里跑C代码，最开始下了个C/C++的扩展程序，以为就可以用Fn+F5正常运行，实则不然，遇到报错！ 1提示这个内容：lauch:program does not exist 并要求我修改launch.json文件，可是我怎么修改也不管用…逐渐开始进入崩溃状态，想要直接写在这**的VSCode…可是作为一个颜控的我沉迷于VSCode的颜值无法自拔，决定再试试… 最终发现问题出现在没有安装MinGW64无法调试，于是搜索教程，前往官网下载，并将bin文件的目录添加到path路径中去。 并最终用gcc -v测试是否安装成功，要注意在cmd里测试，不要像我一样，在cmder里怎么测试都不成功… 安装具体教程点击这个链接 安装插件VSCode不安装插件是没有灵魂的… 我目前还不是很懂，也只是安装了一下几个插件 C/C++ C++ Intellisense Chinese Language Code Runner Seti-theme 运行代码最终用配置好的环境跑了一下hello，world成功编译！ 问题补充（修改于19.8.14）再次出现问题！之前成功编译只是通过了代码右上角的“播放”按键，也就是插件Code Runner，然而F5依然无法通过！ 继续查阅资料，查到一篇比较详细的教程，地址请点击 简单来讲就是还要修改.vscode文件夹里的launch.json和tasks.json文件。 而我是将launch.json修改为，其中gdb.exe的路径需要自己进行修改一下 1234567891011121314151617181920212223242526&#123; "version": "0.2.0", "configurations": [ &#123; "name": "(gdb) Launch", // 配置名称，将会在启动配置的下拉菜单中显示 "type": "cppdbg", // 配置类型，这里只能为cppdbg "request": "launch", // 请求配置类型，可以为launch（启动）或attach（附加） "program": "$&#123;workspaceFolder&#125;/$&#123;fileBasenameNoExtension&#125;.exe",// 将要进行调试的程序的路径 "args": [], // 程序调试时传递给程序的命令行参数，一般设为空即可 "stopAtEntry": false, // 设为true时程序将暂停在程序入口处，一般设置为false "cwd": "$&#123;workspaceFolder&#125;", // 调试程序时的工作目录，一般为$&#123;workspaceFolder&#125;即代码所在目录 "environment": [], "externalConsole": true, // 调试时是否显示控制台窗口，一般设置为true显示控制台 "MIMode": "gdb", "miDebuggerPath": "D:\\MinGW64\\mingw64\\bin\\gdb.exe", // miDebugger的路径，注意这里要与MinGw的路径对应 "preLaunchTask": "g++", // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc "setupCommands": [ &#123; "description": "Enable pretty-printing for gdb", "text": "-enable-pretty-printing", "ignoreFailures": true &#125; ] &#125; ] &#125; 将tasks.json修改为 1234567891011121314151617&#123; "version": "2.0.0", "command": "g++", "args": ["-g","$&#123;file&#125;","-o","$&#123;fileBasenameNoExtension&#125;.exe"], // 编译命令参数 "problemMatcher": &#123; "owner": "cpp", "fileLocation": ["relative", "$&#123;workspaceFolder&#125;"], "pattern": &#123; "regexp": "^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$", "file": 1, "line": 2, "column": 3, "severity": 4, "message": 5 &#125; &#125;&#125; 最终实现F5调试并且可以实现断点debug等功能 使用VSCode编辑博客VSCode让我比较喜欢的一点是在于可以直接打开文件夹，并且继承了终端处理，git等，很多功能我还没有发掘出来，之后会深度体验一下VSCode！]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【STM32】手把手写跑马灯实验]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91%E6%89%8B%E6%8A%8A%E6%89%8B%E5%86%99%E8%B7%91%E9%A9%AC%E7%81%AF%E5%AE%9E%E9%AA%8C.html</url>
    <content type="text"><![CDATA[库函数版本回顾GPIO基础知识4种输入模式： 输入浮空 输入上拉 输入下拉 模拟输入 4种输出模式： 开漏输出 开漏复用功能 推挽式输出 推挽式复用功能 3种最大输出速度： 2MHZ 10MHz 50MHz 寄存器 GPIOx_CRL : 端口配置低寄存器（低8位） GPIOx_CRH: 端口配置高寄存器（高8位） GPIOx_IDR: 端口输入寄存器 GPIOx_ODR: 端口输出寄存器 GPIOx_BSRR: 端口位设置/清除寄存器 GPIOx_BRR : 端口位清除寄存器 GPIOx_LCKR: 端口配置锁存寄存器 跑马灯的硬件连接 LED0连接PB5 LED1连接PE5 库函数介绍 头文件：stm32f10x_gpio.h 源文件：stm32f10x_gpio.c 具体函数1个初始化函数：12345678910void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);//作用：初始化一个或者多个IO口（同一组）的工作方式和速度。该函数主要是操作GPIO_CRL(CRH)寄存器//样例 GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //LED0--&gt;PB.5 端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO口速度为50MHz GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //根据设定参数初始化GPIOB.5 2个读取输入电平函数：123456789uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);//作用：读取某个GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。//举例：GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5);//读取GPIOA.5的输入电平uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);//作用：读取某组GPIO的输入电平。实际操作的是GPIOx_IDR寄存器。//举例：GPIO_ReadInputData(GPIOA);//读取GPIOA组中所有IO口输入电平 2个读取输出电平函数：123456789uint8_t GPIO_ReadOutputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);//作用：读取某个GPIO的输出电平。实际操作的是GPIO_ODR寄存器。//例如：GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_5);//读取GPIOA.5的输出电平uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);//作用：读取某组GPIO的输出电平。实际操作的是GPIO_ODR寄存器。//例如：GPIO_ReadOutputData(GPIOA);//读取GPIOA组中所有io口输出电平 4个设置输出电平函数：123456789void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);//作用：设置某个IO口输出为高电平（1）。实际操作BSRR寄存器//例如：GPIO_SetBits(GPIOB,GPIO_Pin_5); //GPIOB.5设置为高电平，LED高电平不亮void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);//作用：设置某个IO口输出为低电平（0）。实际操作的BRR寄存器。//例如： GPIO_ResetBits(GPIOB,GPIO_Pin_5);//GPIOB.5设置为低电平，LED高电平亮 代码思路 使能IO口时钟。调用函数RCC_APB2PeriphColckCmd(); 初始化IO口模式。调用函数GPIO_Init(); 操作IO口，输出高低电平GPIO_SetBits(),GPIO_ResetBits(); 最终代码1234567//led.h 文件#ifndef __LED_H#define __LED_Hvoid LED_Init(void);#endif 1234567891011121314151617181920212223//led.c 文件#include "led.h"#include "stm32f10x.h"void LED_Init(void)&#123; GPIO_InitTypeDef GPIO_InitStructure; //GPIO初始化定义 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); //GPIOB时钟使能 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); //GPIOE时钟使能 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //端口配置 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //IO口速度为50MHz GPIO_Init(GPIOB,&amp;GPIO_InitStructure); //根据设定参数初始化GPIOB.5 GPIO_SetBits(GPIOB,GPIO_Pin_5); //GPIOB.5设置为高电平，LED高电平不亮 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOE,&amp;GPIO_InitStructure); GPIO_SetBits(GPIOE,GPIO_Pin_5);&#125; 1234567891011121314151617181920// main.c#include "stm32f10x.h"#include "led.h"#include "delay.h"int main(void)&#123; LED_Init(); delay_init(); while(1)&#123; GPIO_SetBits(GPIOB,GPIO_Pin_5); GPIO_SetBits(GPIOE,GPIO_Pin_5); delay_ms(500); GPIO_ResetBits(GPIOB,GPIO_Pin_5); GPIO_ResetBits(GPIOE,GPIO_Pin_5); delay_ms(500); &#125;&#125; 寄存器版本代码思路 使能IO口时钟。配置寄存器RCC_APB2ENR 初始化IO口模式。配置寄存器GPIOx_CRH/CRL 操作IO口，输出高低电平。配置寄存器GPIOX_ODR或者BSRR/BRR 最终代码12345678//led.h 文件//与库函数版本相同#ifndef __LED_H#define __LED_Hvoid LED_Init(void);#endif 123456789101112131415161718192021//led.c 文件#include "led.h"#include "stm32f10x.h"void LED_Init(void)&#123; RCC-&gt;APB2ENR |= 1&lt;&lt;3; //使能IO口时钟，GPIOB RCC-&gt;APB2ENR |= 1&lt;&lt;6; //使能IO口时钟, GPIOE //GPIOB.5 GPIOB-&gt;CRL &amp;= 0xFF0FFFFF; //先用与运算将欲修改的位修改为0（修改第六位） GPIOB-&gt;CRL |= 0x00300000; //再用或运算将PB5修改为通用推挽输出，即0011，也就是3 GPIOB-&gt;ODR |= 1&lt;&lt;5; //将PB5的ODR寄存器设置为高电平，即最开始不亮 //GPIOE.5 GPIOE-&gt;CRL &amp;= 0xFF0FFFFF; //同理 GPIOE-&gt;CRL |= 0x00300000; GPIOE-&gt;ODR |= 1&lt;&lt;5; &#125; 12345678910111213141516171819//main 文件#include "stm32f10x.h"#include "led.h"#include "delay.h"int main()&#123; LED_Init(); delay_init(); GPIOB-&gt;ODR |= 1&lt;&lt;5; GPIOE-&gt;ODR |= 1&lt;&lt;5; delay_ms(500); GPIOB-&gt;ODR = ~(1&lt;&lt;5); GPIOE-&gt;ODR = ~(1&lt;&lt;5); delay_ms(500);&#125; 位带操作版本位操作原理把每个比特膨胀为一个32位的字，当访问这些字的时候就达到了访问比特的目的，比如说BSRR寄存器有32个位，那么可以映射到32个地址上，我们去访问（读-改-写）这32个地址就达到访问32个比特的目的。 代码思路 使能IO口时钟。调用函数RCC_APB2PeriphColckCmd() 初始化IO口模式。调用函数GPIO_Init() 操作IO口，输出高低电平。使用位带操作。 最终代码123456789//led.h 文件#ifndef __LED_H#define __LED_H#define LED0 PBout(5)// PB5 添加宏定义#define LED1 PEout(5)// PE5 void LED_Init(void);#endif 123456789101112131415161718192021//main 文件#include "stm32f10x.h"#include "led.h"#include "delay.h"int main()&#123; LED_Init(); delay_init(); while(1)&#123; LED0 = 1; LED1 = 1; delay_ms(500); LED0 = 0; LED1 = 0; delay_ms(500); &#125;&#125;]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用GCC编译Keil5的代码，了解GCC工具链]]></title>
    <url>%2FMicroController%2F%E3%80%90STM32%E3%80%91%E7%94%A8GCC%E7%BC%96%E8%AF%91Keil5%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BA%86%E8%A7%A3GCC%E5%B7%A5%E5%85%B7%E9%93%BE.html</url>
    <content type="text"><![CDATA[用GCC编译Keil5的代码，了解GCC工具链引言本周接到任务，首先是熟悉STM32cubemx，既然是熟悉框也就不做太高的要求，毕竟也只是一个提升效率的工具，我就按照教程新建了一个简单地模板，算是知道怎么用cubemx从头开始建一个工程了。 而本周的第二个任务就是研究用GCC工具链编译Keil5的代码，这个的确对我来说难度不小，算是卡了我将近三天的时间，而出现这个问题的原因就是我基础不够牢靠，Keil5软件最基本的知识没有掌握，导致找不到问题的原因所在。还好我中途没有放弃，一直在尝试，也一直在找可能的原因，最终找到了，也算功夫不负有心人吧。 特此记录一下，因为我在出现这些问题之后并不能在网上找到答案，借此机会来帮助之后和我一样基础不好的小白吧。 问题产生在研究用GCC编译Keil5的代码的时候，我在网上找到了CSDN上的一个教程，讲解的还是十分详细的。 但我按照教程，把我用cubemx建的工程搞了一遍却出现了很多很多的bug，具体如下： 遇到这个问题之后我也查了一下，并没有找到原因，多数是说我没有定义，但我也不知道应该怎么定义呀！ 寻找问题我的直觉觉得问题可能出在教程中配置的部分，但同样的配置为什么会出现不同的结果呢？ 我于是按照正点原子的教程从头开始看了一下怎么配置一个用armcc编译的流水灯模板，因为之前我没自己搞过模板，于是发现了很多我之前不知道的细节，比如添加添加定义，头文件，修改output输出文件夹，而我出现的问题就是define没有添加，导致未定义。 12//在图中define一定要添加Define: USE_HAL_DRIVER,STM32F103xE,USE_HAL_DRIVER,STM32F103xE 解决之后成功编译！ 附上可编译模板的链接]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>keil</tag>
        <tag>GCC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【从零入门Qt】开发一款属于自己的串口调试助手]]></title>
    <url>%2FOtherTechnique%2F%E3%80%90%E4%BB%8E%E9%9B%B6%E5%85%A5%E9%97%A8Qt%E3%80%91%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%B2%E5%8F%A3%E8%B0%83%E8%AF%95%E5%8A%A9%E6%89%8B.html</url>
    <content type="text"><![CDATA[暑假来深圳这边实习，做的是嵌入式方向，负责人分配给我的第一个任务是用Qt写一个串口调试助手。这个任务总体来讲难度适中，尽管我没接触过Qt，但能查到很多很多的资料，甚至包括别人写好的源代码，所以有很多的学习资源。 我第一天在同学的推荐下，看了一个入门的文档，《Qt 学习之路 2》，其中内容讲的比较基础，基本可以理解，算是能对Qt的语法了解个大概。而且如果实在不懂，也可以参看b站上的视频教程，是黑马程序员的教程，视频内容比较冗长，但对于初学者来说可能更好理解，各取所需，看个人选择。 因为负责人只给了我三天的时间，所以我也就花了一天左右的时间看教程，就开始看我在网上看的一份源码了。当时我的进度是黑马程序员看了不到10个视频，《Qt 学习之路 2》看了不到20节教程，虽然说看了不少，但我当时还是很慌的，对于我这种小白来说，还是不知道源代码是什么意思，但这个时候我能大概明白每个函数要做什么功能了，也就是我看懂了函数名，但函数里的句子我看不懂。 然后我就选择了按照这份代码自己复刻一份，算是尝试着自己写一下。 于是我新建了一个project，名字是Myserialport，发现源代码中main.cpp完全一样，也就是一个窗体的显示功能，很好理解，直接略去~ 上面的mainwindow.h文件里面有很多库函数的引用，函数的声明，我姑且认为不重要，暂时略去 而代码最多的就集中在mainwindow.cpp文件里了，也是我最需要解决的部分！ 这是我新建工程后的代码： 1234567891011121314#include "mainwindow.h"#include "ui_mainwindow.h"MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this);&#125;MainWindow::~MainWindow()&#123; delete ui;&#125; 而源代码在MainWindow::MainWindow(QWidget *parent)中添加了很多窗体生成的初始化语句 123456789101112131415MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); textstate_receive = false; //初始化发送窗口状态为文本模式 textstate_send = false; //初始化接收窗口状态为文本模式 serialport = new QSerialPort; //创建QSerialPort类，需要在头文件中添加#include &lt;QSerialPort&gt; ui-&gt;send_button-&gt;setEnabled(false); //初始化接收按钮不可用 ui-&gt;close_port-&gt;setEnabled(false); //初始化接收按钮不可用 ui-&gt;Receive_text_window-&gt;setReadOnly(true);//讲接收窗口设置为只读窗口 setWindowTitle("串口调试助手"); //设置程序的标题 setWindowIcon(QIcon(":/images/exe.jpg")); //设置程序左上角图标 find_port(); //查找可用串口函数&#125; 以上语句还是比较好理解的，每句话我都进行了注释。 下面的代码就是定义各个函数，而.h文件里的很多函数声明也就很好理解了，也就是在.h文件里定义一下各个函数 比如以下很重要的两个函数，用于实现数据的发送和接收 123456789101112131415161718//发送数据void MainWindow::on_send_button_clicked()&#123; if(textstate_send == false) //文本模式 &#123; serialport-&gt;write(ui-&gt;Send_text_window-&gt;toPlainText().toUtf8()); &#125; if(textstate_send == true) //hex模式 &#123; QString str = ui-&gt;Send_text_window-&gt;toPlainText(); int num = str.toInt(); str = str.setNum(num,16); ui-&gt;Send_text_window-&gt;clear(); ui-&gt;Send_text_window-&gt;append(str); serialport-&gt;write(ui-&gt;Send_text_window-&gt;toPlainText().toLatin1()); &#125;&#125; 123456789101112131415161718192021222324252627//窗口显示串口传来的数据void MainWindow::Read_Data()&#123; QByteArray buf; buf = serialport-&gt;readAll(); if(!buf.isEmpty()) //将数据显示到文本串口 &#123; if(textstate_receive == false) //文本模式 &#123; QString str = ui-&gt;Receive_text_window-&gt;toPlainText(); str += tr(buf); ui-&gt;Receive_text_window-&gt;clear(); ui-&gt;Receive_text_window-&gt;append(str); &#125; if(textstate_receive == true) //hex模式 &#123; QString str = ui-&gt;Receive_text_window-&gt;toPlainText(); // byteArray 转 16进制 QByteArray temp = buf.toHex().toUpper(); str += tr(temp); ui-&gt;Receive_text_window-&gt;clear(); ui-&gt;Receive_text_window-&gt;append(str); &#125; &#125; buf.clear(); //清空缓存区&#125; 最后实现了以下的界面，以及文本模式和16进制（hex模式）两种模式转换的数据收发 p.s.：尝试了很久想要解决中文无法显示的问题，最终无果… 有需要的话可以在这个链接下载嗷~]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌入式开发学习笔记]]></title>
    <url>%2FMicroController%2F%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[Linux distribution (linux的发行版本)软件，shell 保护层，kernel内核，硬件 linux系统，完整的分层模型 RedHat：server 服务器 面向企业用户 具有license CentOS：已经被红帽子收购，开源免费版本，区别于企业版，比较稳定 以上两款界面不好看，不追求绚丽的东西 Ubuntu：稳定性不如上面两个，但适用于普通用户，中文支持，软件支持做的都比较好 ubuntu操作 sudo 为普通命令提升权限 sudo passwd root su - 切换到系统的身份 apt-get update更新源，用于下载新的安装包（如果是普通用于，记得在前面加sudo 尽量用命令行的方式来学习linux vim安装 apt-get install vim-nox vi已经安装，是一个编辑软件的记事本 vim回车，进入 退出，敲：q（不知道要不要加！） vim全键盘操作，效率很高 cd / 根目录 c—change d—directory 目录 ls 不要在根目录里面操作 回去 cd vi /etc/ vi 命令模式，编辑模式，用 i 切换模式，esc键退出 ssh-secure shell SecureCRT安装 sshd回车 apt-get install openssh-server ifconfig net add: rz zmodem r:receive sz zmodem s:send samba apt-get install samba]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦里花落知多少]]></title>
    <url>%2FOtherArticle%2F%E6%A2%A6%E9%87%8C%E8%8A%B1%E8%90%BD%E7%9F%A5%E5%A4%9A%E5%B0%91.html</url>
    <content type="text"><![CDATA[很喜欢何炅说的一段话：要得到你必须要付出，要付出你还要学会坚持，如果你真的觉得很难，那你就放弃，但你放弃了就不要抱怨，我觉得人生就是这样，世界真的是公平的，每个人都是通过自己的努力，去决定自己生活的样子！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Hexo博客搭建经历]]></title>
    <url>%2FBlog%2F%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[为什么要做自己的博客？说到为什么要这么做，这个想法也是已经有很久了。当时的起因是我想通过互联网上的某个平台来记录自己的学习笔记或者自己的一些思考。在知乎等搜索了很多，都没有找到太合适的，其中包括公众号，简书，csdn等等。我觉得不合适的原因有的是因为网站太过烟火气，对我来说我觉得不够“干净”。有的是因为我觉得和我的圈子不符合，有的是因为我个人的喜好，最终都没有选择。有一天就突然萌生了做一个自己的博客的想法！ 但问题来了，怎么做呢？我完全摸不到头脑。我就去知乎查了一下看到了蛮多科普的帖子，但一翻，好长好长，其中也包括很多很多的代码。对于一个机械专业的学生来说，看到这些内心是恐惧的。于是…我就把那篇帖子收藏了，打算等我有时间再做…当时可能觉得的时间是大四…可是这个想法实际上一直深深的埋在我的心里。 上周，这学期该忙的事情几乎结束，剩下的就是为了期末考试做准备了，我向来是一个喜欢拖延的人，不到考试前一周应该是打不起学习的兴趣的。我就在教室看着电脑，可能又萌生了写点东西的想法，奈何没有平台给我发挥。于是突然决定，就现在！把博客给我搞出来 我花了多少时间？总共时长大概是3天白天的时间，对于我这个毫无基础的IT小白来说还是可以接受的（毕竟如果我不是搞这个的话估计也不会学习吧） 我是怎么做出来的？遇到了很多问题，也查了很多资料，通过别人的教程一步一步完善自己的博客 推荐链接：知乎上的一篇文章，我的启蒙 看了这个博客之后大部分操作就都可以完成了，当然你可能会像我一样，遇到很多的问题，那么怎么办呢？当然是自己查！而且很容易查到你想要的解决方法 这篇博客是我的努力目标，当时就是朝着这个方向努力完善 这篇博客讲了很多博客美化的内容，我都是自己一步一步搞的 另一个美化博客的教程，也很不错哦 以上部分完成了，你的博客基本就完成啦！如果你遇到了什么问题，都可以去google，相信你能得到你想要的答案~ 会不会出教程？应该不会，教程太多了，我还没那么牛，等我再学习学习吧… 如果换电脑了，想在新电脑上写博客，怎么迁移一个比较好的教程 想在两台电脑上同时写博客的方法利用git的分支功能！ 把生成的静态网页上传到master分支，把写的原文件上传到新建的hexo分支 每次在另一台电脑上写博客前，先git pull将本地文件更新，而在写好文章后要记得用 123git add . git commit -m &quot;&quot;git push 参考了知乎上的一篇答案，十分详细，对新手小白十分友好，点击跳转 做完这个对git的分支功能有了更深刻的认识~]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法总结整理]]></title>
    <url>%2FBlog%2FMarkdown-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86.html</url>
    <content type="text"><![CDATA[Markdown文本学习就不总结了 直接上传一个我觉得不错的链接吧 印象笔记Markdown文本入门指南 Markdown文本公式写法超全公式指南，简单易懂 hhh ，比如：$$E=mc^2$$ 然而用这个写法在Hexo Next主题下网页上并不会显示出公式，我查了一下 这个教程不错 打矩阵的时候你会发现无法多行显示，这个教程告诉了我们解决办法 Markdown代码块的使用方法1#include1 &lt;iostream&gt; 在句首加”” 即可，即键盘左上角123456789101112131415161718192021222324252627282930313233# Markdown引用的方法&gt; 引用内容引用方法在句首‘ &gt; ’加空格即可# 修改文字的颜色```html浅红色文字：&lt;font color=&quot;#dd0000&quot;&gt;浅红色文字：&lt;/font&gt;&lt;br /&gt; 深红色文字：&lt;font color=&quot;#660000&quot;&gt;深红色文字&lt;/font&gt;&lt;br /&gt; 浅绿色文字：&lt;font color=&quot;#00dd00&quot;&gt;浅绿色文字&lt;/font&gt;&lt;br /&gt; 深绿色文字：&lt;font color=&quot;#006600&quot;&gt;深绿色文字&lt;/font&gt;&lt;br /&gt; 浅蓝色文字：&lt;font color=&quot;#0000dd&quot;&gt;浅蓝色文字&lt;/font&gt;&lt;br /&gt; 深蓝色文字：&lt;font color=&quot;#000066&quot;&gt;深蓝色文字&lt;/font&gt;&lt;br /&gt; 浅黄色文字：&lt;font color=&quot;#dddd00&quot;&gt;浅黄色文字&lt;/font&gt;&lt;br /&gt; 深黄色文字：&lt;font color=&quot;#666600&quot;&gt;深黄色文字&lt;/font&gt;&lt;br /&gt; 浅青色文字：&lt;font color=&quot;#00dddd&quot;&gt;浅青色文字&lt;/font&gt;&lt;br /&gt; 深青色文字：&lt;font color=&quot;#006666&quot;&gt;深青色文字&lt;/font&gt;&lt;br /&gt; 浅紫色文字：&lt;font color=&quot;#dd00dd&quot;&gt;浅紫色文字&lt;/font&gt;&lt;br /&gt; 深紫色文字：&lt;font color=&quot;#660066&quot;&gt;深紫色文字&lt;/font&gt;&lt;br /&gt; 效果如下： 浅红色文字：浅红色文字： 深红色文字：深红色文字 浅绿色文字：浅绿色文字 深绿色文字：深绿色文字 浅蓝色文字：浅蓝色文字 深蓝色文字：深蓝色文字 浅黄色文字：浅黄色文字 深黄色文字：深黄色文字 浅青色文字：浅青色文字 深青色文字：深青色文字 浅紫色文字：浅紫色文字 深紫色文字：深紫色文字 修改字体大小123size为1：&lt;font size="1"&gt;size为1&lt;/font&gt;&lt;br /&gt; size为2：&lt;font size="2"&gt;size为2&lt;/font&gt;&lt;br /&gt; size为3：&lt;font size="3"&gt;size为3&lt;/font&gt;&lt;br /&gt; 效果如下： size为1：size为1size为2：size为2size为3：size为3 修改背景色1234&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF00FF&gt;背景色的设置是按照十六进制颜色值：#7FFFD4&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#FF83FA&gt;背景色的设置是按照十六进制颜色值：#FF83FA&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#D1EEEE&gt;背景色的设置是按照十六进制颜色值：#D1EEEE&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=#C0FF3E&gt;背景色的设置是按照十六进制颜色值：#C0FF3E&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 背景色的设置是按照十六进制颜色值：#7FFFD4 背景色的设置是按照十六进制颜色值：#FF83FA 背景色的设置是按照十六进制颜色值：#D1EEEE 背景色的设置是按照十六进制颜色值：#C0FF3E]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
