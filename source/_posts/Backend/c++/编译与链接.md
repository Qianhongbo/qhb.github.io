---
title: 编译与链接
date: 2022-11-20 11:23:15
categories: 
- c++
tags: 
- c++
---

## 编译的目的

我们常见的C/C++ 语言，CPU 是无法理解的，这就需要将我们编写好的代码最终翻译为机器可执行的**二进制指令**，编译的过程本质上也即是翻译的过程，当然中间涉及的细节非常复杂。

## 编译过程

编译器读取源文件 cpp，并将其翻译为可执行文件「ELF」，ELF 文件可以经过操作系统进行加载执行。常见的编译过程分为四个过程：**编译预处理、编译、汇编、链接**。

![](https://pic.leetcode-cn.com/1661172766-jkudLd-1_1_1.png)

- 编译预处理：在预编译过程中主要处理源代码中的预处理指令，比如引入头文件（#include），去除注释，处理所有的条件编译指令（#ifdef, #ifndef, #else, #elif, #endif），宏的替换（#define），添加行号，保留所有的编译器指令；
- 编译：针对预处理后的文件进行**词法分析、语法分析、语义分析、符号汇总、汇编代码**生成，并针对程序的结构或者特定的 CPU 平台进行**优化**，其中涉及的过程较为复杂。简单来说编译的过程即为将 .cpp 源文件翻译成 **.s** 的汇编代码；
- 汇编：将汇编代码 .s 翻译成机器指令 **.o** 文件，一个 .cpp 文件只会生成一个 .o 文件；
- 链接：汇编程序生成的目标文件即为 .o 文件，单独的 .o 文件可能无法执行。因为一个程序可能由多个源文件组成，此时就存在多个 .o 文件。文件 A 中的函数引用了另一个文件 B 中定义的符号或者调用了某个库文件中的函数，这就需要链接处理。那链接的目的就是**将这些文件对应的目标文件连接成一个整体**，从而生成一个可被操作系统加载执行的ELF 程序文件。

## 静态链接与动态链接

- **静态链接**：代码在生成可执行文件时，将该程序所需要的**全部**外部调用函数全部**拷贝**到最终的**可执行程序文件中**，在该程序被执行时，该程序运行时所需要的全部代码都会被装入到该进程的虚拟地址空间中。在 Linux 系统下，静态链接库一般以 **.a** 文件，我们可以将多个 .o 文件链接成一个静态链接库。
- **动态链接**：代码在生成可执行文件时，该程序所调用的部分程序被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中**记录了共享对象的名字等一些信息**，最终生成的 ELF 文件中并**不包含**这些调用程序二进制指令。在程序执行时，当需要调用这部分程序时，操作系统会从将这些动态链或者共享对象进行加载，并将全部内容会被**映射**到该进行运行的虚拟地址的空间。在 Linux 系统下，动态链接库一般以 **.so** 文件，我们可以将多个 .o 文件链接成一个动态链接库。

### 优缺点

|          | 静态链接                                                     | 动态链接                                 |
| -------- | ------------------------------------------------------------ | ---------------------------------------- |
| 空间     | 浪费空间，每个可执行程序都会有目标文件的一个副本             | 动态链接节省内存                         |
| 更新     | 如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难） | 更新方便                                 |
| 效率     | 执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容 | 相比静态链接会有一定的性能损失           |
| 连接方式 | 静态链接是由连接器完成的                                     | 动态链接最终是由操作系统来完成链接的功能 |

> 动态链接在不同的操作系统下可能由不同的实现原理，比如在 Linux 系统下，动态链接库通常以 **.so** 文件存在，在 windows 下同下，动态链接库一般以 **.dll** 文件存在。
